---
title: 算法基础笔记
author: AshGrey
date: 2024-04-16 00:00:00 +0800
categories: [Coumputer Science, Algorithm]
tags: [Computer Science, Algorithm]
math: true
---

> 本文章所属领域：
>
> [实践产业知识 - 工业产业 - 计算机科学 - 算法]({% post_url /Computer Science/2024-02-08-计算机科学：索引笔记 %})
{: .prompt-info}

<br>

## 1 分析算法的方法

<br>

### 1.1 以插入排序为例分析算法

<br>

我们考虑一个排序问题：
- 输入：$n$ 个数的一个序列 $a_1,\cdots,a_n$；
- 输出：输入序列的一个排列 $a_1',\cdots,a_n'$，满足 $a_1'\leq a_2'\cdots\leq a_n'$；

<br>

插入排序（insertion-sort）是一种解决以上排序问题的算法，其中的参数是一个数组 $A\left[1..n\right]$，包含长度为 $n$ 的要排列的一个序列，其伪代码如下：

<br>

> **算法 1.1-1 插入排序**
>
> ``` pseudocode
> procedure | insertion-sort(A)
> 
> for j := 2 to A.length
>     key := A[j]
>     // Insert A[j] into the sorted sequence A[1..j-1]
>     i := j - 1
>     while i > 0 and A[i] > key
>         A[i + 1] := A[i]
>         i := i - 1
>     A[i + 1] = key
> ```

<br>

由于算法最终要在计算机上实现，为了评判最有效的算法，需要度量算法执行的时间，因此必须要有能够使用的实现算法的模型包括描述所用的资源及其代价的模型。我们一般使用的是通用的单处理器计算模型——随机访问机（random-access machine, RAM）来实现算法。在 RAM 中，指令串行执行，没有并发操作。

<br>

RAM 模型包括真实计算机中常见的指令：
- 算术指令：加法、减法、乘法、除法、取余、向下取整、向上取整；
- 数据移动指令：装入、存储、复制；
- 控制指令：条件与无条件转移、子程序调用和返回。

以上所有指令所需的时间都是常量。

<br>

一般来说，算法需要的时间与输入的规模同步增长，所以通常把一个程序的运行时间描述成其输入规模的函数。输入规模的最佳定义依赖于研究的问题，例如输入是数组时，最自然的度量是**输入数组的项数**；输入是图时，最自然的度量是**图的顶点数和边数**。对于运行时间，我们一般采用这样的观点：执行每行伪代码需要常量时间，虽然一行与另一行可能需要不同数量的时间，但是我们假定第 $i$ 行的每次执行时间为 $c_i$，其中 $c_i$ 是一个常量。

<br>

下面我们分析插入排序的运行时间，设 $t_j$ 为伪代码中`while`语句运行的次数，注意当一个`for`或`while`循环按照通常的方式推出时，执行测试的次数比执行循环体的次数多 $1$。我们可以得到下面的分析表：

<br>

|行数|伪代码|运行时间|次数|
|:---:|:---:|:---:|:---:|
|1|`for j = 2 to A.length`|$c_1$|$n$|
|2|`key := A[j]`|$c_2$|$n-1$|
|3|注释|$0$|$n-1$|
|4|`i := j - 1`|$c_4$|$n-1$|
|5|`while i > 0 and A[i] > key`|$c_5$|$\sum_{j=2}^nt_j$|
|6|`A[i + 1] := A[i]`|$c_6$|$\sum_{j=2}^n(t_j-1)$|
|7|`i := i - 1`|$c_7$|$\sum_{j=2}^n(t_j-1)$|
|8|`A[i + 1] := key`|$c_8$|$n-1$|

<br>

该算法的运行时间是执行每条语句的运行时间之和，设总运行时间为 $T(n)$，则

$$
    \begin{aligned}
        T(n)=&c_1n+c_2(n-1)+c_4(n-1)+c_5\sum_{j=2}^nt_j\\
        &+c_6\sum_{j=2}^n(t_j-1)+c_7\sum_{j=2}^n(t_j-1)+c_8(n-1)
    \end{aligned}
$$

可以看到 $t_j$ 是与输入的序列有关的。我们可以分析它的最佳运行时间和最坏运行时间：
- 最佳运行时间：如果序列已经排好序，则出现最佳情况，这时可以看到对每个 $j=2,\cdots,n$，当 $i$ 取初值 $j-1$ 时，有 $A\left[j\right]\leq\text{key}$，此时`while`循环不执行，于是最佳运行时间为

    $$
        T_{\text{min}}(n)=an+b
    $$

    其中 $a,b$ 都与单行语句的运行时间 $c_i$ 有关，实际上 $a=c_1+c_2+c_4+c_5+c_8$，$b=-(c_2+c_4+c_5+c_8)$
- 最坏运行时间：如果序列是反序的，则出现最坏情况，这时必须将每个元素 $A\left[j\right]$ 和整个已经排序好的子序列 $A\left[1..j-1\right]$ 中的所有元素进行比较，所以有 $t_j=j$，注意到

    $$
        \sum_{j=2}^nj=\frac{n(n+1)}{2}-1,\quad\sum_{j=2}^n(j-1)=\frac{n(n-1)}{2}
    $$

    因此最坏运行时间为

    $$
        T_{\text{max}}(n)=an^2+bn+c
    $$

    其中 $a,b,c$ 都与单行语句的运行时间 $c_i$ 有关，实际上 $a=(c_5+c_6+c_7)/2$，$b=c_1+c_2+c_4+(c_5-c_6-c_7)/2+c_8$，$c=-(c_2+c_4+c_5+c_8)$

<br>

一般来说，我们只关心一个算法的最坏运行时间，这是因为一个算法的最坏运行时间给出了任何输入的运行时间的一个上界，确保该算法不会需要更长的时间。事实上，我们更加对一个算法的运行时间的**增长率**或者**增长量级**感兴趣，所以只用考虑算法的最坏运行时间的最重要项，例如插入排序的最坏运行时间可以记作 $\Theta(n^2)$。

<br>

如果一个算法的最坏运行时间具有比另一个算法的最坏运行时间更低的增长量级，那么我们通常认为前者比后者更有效