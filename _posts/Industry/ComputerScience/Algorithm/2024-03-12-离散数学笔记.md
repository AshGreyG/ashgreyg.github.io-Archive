---
title: 离散数学笔记
author: AshGrey
date: 2024-03-12 00:00:00 +0800
categories: [Coumputer Science, Algorithm]
tags: [Computer Science, Algorithm, Discrete Mathematics]
math: true
---

> 本文章所属领域：
>
> [实践产业知识 - 工业产业 - 计算机科学 - 算法]({% post_url /Computer Science/2024-02-08-计算机科学：索引笔记 %})
{: .prompt-info}

<br>

## 1 逻辑和证明

<br>

### 1.1 命题逻辑

<br>

命题（propositions）是一个称述语句，它或真或假，但不可能既真又假。

<br>

> **定义 1.1-1 否定（negation）**
>
> 令 $p$ 为一命题，则 $p$ 的否定记作 $\lnot p$ 或者 $\bar{p}$，指「不是 $p$ 所指的情形」，$p$ 的真值与 $\lnot p$ 相反

<br>

> **定义 1.1-2 合取（conjunction）**
>
> 令 $p$ 和 $q$ 为命题，则 $p$ 和 $q$ 的合取即命题「$p$ 并且 $q$」，记作 $p\wedge q$，当 $p$ 和 $q$ 都是真时，$p\wedge q$ 为真，否则为假

<br>

> **定义 1.1-3 析取（disjunction）**
>
> 令 $p$ 和 $q$ 为命题，则 $p$ 和 $q$ 的析取即命题「$p$ 或者 $q$」，记作 $p\vee q$，当 $p$ 和 $q$ 都是假时，$p\vee q$ 为假，否则为真

<br>

> **定义 1.1-4 异或（exclusive）**
>
> 令 $p$ 和 $q$ 为命题，则 $p$ 和 $q$ 的异或即命题「当 $p$ 和 $q$ 中恰好只有一个为真时命题为真，否则为假」，记作 $p\oplus q$

<br>

异或 $p\oplus q$ 实际可以表述为 $(p\wedge\lnot q)\vee(\lnot p\wedge q)$，这意味着异或并不是逻辑的基本运算。

<br>

> **定义 1.1-5 条件语句（conditional statement）**
>
> 令 $p$ 和 $q$ 为命题，条件语句 $p\rightarrow q$ 是命题「如果 $p$，则 $q$」。当 $p$ 为真而 $q$ 为假时，条件语句 $p\rightarrow q$ 为假，否则为真（当 $p$ 为假时是无意义的真）。命题 $p$ 被称为假设（hypothesis）或前件（antecedent）或前提（premise），命题 $q$ 被称为结论（conclusion）或后件（consequence）

<br>

条件语句有时候又被称为蕴含（implication）。条件语句的自然语言表达相当多，在中文语境中基本表述为「如果···那么···」。由条件语句可以构造出一些新的条件语句，例如：
- $q\rightarrow p$ 称为 $p\rightarrow q$ 的**逆命题**（converse）；
- $\lnot p\rightarrow\lnot q$ 称为 $p\rightarrow q$ 的**否命题**（inverse）；
- $\lnot q\rightarrow\lnot p$ 称为 $p\rightarrow q$ 的**逆否命题**（contrapositive）。

当两个复合命题总是具有相同的真值时，无论其命题变量的真值是什么，我们称它们是等价的（equivalent）。根据真值表，条件语句 $p\rightarrow q$ 与其逆否命题 $\lnot q\rightarrow\lnot p$ 是等价的，其逆命题 $q\rightarrow p$ 和 否命题 $\lnot p\rightarrow\lnot q$ 是等价的。

<br>

> **定义 1.1-6 双条件语句（biconditional statement）**
>
> 令 $p$ 和 $q$ 为命题，双条件语句 $p\leftrightarrow q$ 是命题「$p$ 当且仅当 $q$」，当 $p$ 和 $q$ 有同样的真值时，双条件语句 $p\leftrightarrow q$ 为真，否则为假。双条件语句又被称为双向蕴含（bi-implication）

<br>

双条件语句又可以使用缩写符号 $\text{iff}$ 或者复合语句 $(p\rightarrow q)\wedge(q\rightarrow p)$ 表示。

<br>

可以规定逻辑运算符的顺序，使得之后的复合语句不需要使用大量的括号：
- 1级：否定 $\lnot$
- 2级：合取 $\wedge$
- 3级：析取 $\vee$，一般仍然使用括号区分合取和析取的作用顺序
- 4级：蕴含 $\rightarrow$
- 5级：双向蕴含 $\leftrightarrow$，一般仍然使用括号区分蕴含和双向蕴含的作用顺序

<br>

### 1.2 命题等价式

<br>

> **定义 1.2-1 永真式（tautology）**
>
> 一个无论命题变量的值为多少，真值永远是真的复合命题被称为永真式或者重言式（tautology）。一个真值永远是假的复合命题被称为矛盾式（contradiction）。既不是永真式也不是矛盾式的复合命题被称为可能式（contingency）

<br>

> **定义 1.2-2 逻辑等价（logically equivant）**
>
> 如果 $p\leftrightarrow q$ 是永真式，则复合命题 $p$ 和 $q$ 称为逻辑等价的。用记号 $p\equiv q$ 或者 $p\Leftrightarrow q$ 表示逻辑等价

<br>

判断两个复合命题是否是逻辑等价的可以使用真值表（对于命题变量较少的复合命题来说简单，命题变量较多时，应该通过简单的情形推广到一般情形）进行判断，使用这个方法，可以给出以下逻辑等价式子：

<br>

|逻辑等价式|名称|
|:---:|:---:|
|$p\wedge\mathsf{T}\Leftrightarrow p$，$p\vee\mathsf{F}\Leftrightarrow p$|恒等律（Identity）|
|$p\vee\mathsf{T}\Leftrightarrow\mathsf{T}$，$p\wedge\mathsf{F}\Leftrightarrow\mathsf{F}$|支配律（Domination）|
|$p\vee p\Leftrightarrow p$，$p\wedge p\Leftrightarrow p$|幂等律（Idempotent）|
|$\lnot(\lnot p)\Leftrightarrow p$|双重否定律（Double Negation）|
|$p\vee q\Leftrightarrow q\vee p$，$p\wedge q\Leftrightarrow q\wedge p$|交换律（Commutative）|
|$(p\vee q)\vee r\Leftrightarrow p\vee(q\vee r)$，$p\wedge(q\wedge r)\Leftrightarrow(p\wedge q)\wedge r$|结合律（Associative）|
|$p\vee(q\wedge r)\Leftrightarrow(p\vee q)\wedge(p\vee r)$，$p\wedge(q\vee r)\Leftrightarrow(p\wedge q)\vee(p\wedge r)$|分配律（Distributive）|
|$\lnot(p\wedge q)\Leftrightarrow\lnot p\vee\lnot q$，$\lnot(p\vee q)\Leftrightarrow\lnot p\wedge\lnot q$|德·摩根律（De Morgan）|
|$p\vee(p\wedge q)\Leftrightarrow p$，$p\wedge(p\vee q)\Leftrightarrow p$|吸收律（Absorption）|
|$p\vee\lnot p\Leftrightarrow\mathsf{T}$，$p\wedge\lnot p\Leftrightarrow\mathsf{F}$|否定律（Negation）|

<br>

以上都是否定、析取和合取的逻辑等价表达式，还可以给出蕴含和双向蕴含的逻辑等价表达式：

$$
    \begin{aligned}
        p\rightarrow q&\Leftrightarrow\lnot p\vee q\\
        p\rightarrow q&\Leftrightarrow\lnot q\rightarrow\lnot p\\
        p\vee q&\Leftrightarrow\lnot p\rightarrow q\\
        p\wedge q&\Leftrightarrow\lnot(p\rightarrow\lnot q)\\
        \lnot(p\rightarrow q)&\Leftrightarrow p\wedge\lnot q\\
        (p\rightarrow q)\wedge(p\rightarrow r)&\Leftrightarrow p\rightarrow(q\wedge r)\\
        (p\rightarrow r)\wedge(q\rightarrow r)&\Leftrightarrow(p\vee q)\rightarrow r\\
        (p\rightarrow q)\vee(p\rightarrow r)&\Leftrightarrow p\rightarrow (q\vee r)\\
        (p\rightarrow r)\vee(p\rightarrow r)&\Leftrightarrow(p\wedge q)\rightarrow r\\
        p\leftrightarrow q&\Leftrightarrow(p\rightarrow q)\wedge(q\rightarrow p)\\
        p\leftrightarrow q&\Leftrightarrow\lnot q\leftrightarrow\lnot p\\
        p\leftrightarrow q&\Leftrightarrow(p\wedge q)\vee(\lnot p\wedge\lnot q)\\
        \lnot(p\leftrightarrow q)&\Leftrightarrow p\leftrightarrow\lnot q
    \end{aligned}
$$

<br>

因为上述逻辑等价式最多只涉及三个命题变量，真值表并不复杂。当涉及非常多的命题变量时再使用真值表就过于麻烦了。用 $\bigvee_{j=1}^{n}p_j$ 表示 $p_1\vee \cdots\vee p_n$，用 $\bigwedge_{j=1}^n p_j$ 表示 $p_1\wedge\cdots\wedge p_n$。则一般情形的 De Morgan 律可以表述为：

$$
    \lnot\left(\bigvee_{j=1}^np_j\right)\Leftrightarrow\bigwedge_{j=1}^n\lnot p_j,\quad\lnot\left(\bigwedge_{j=1}^np_j\right)\Leftrightarrow\bigvee_{j=1}^n\lnot p_j
$$

<br>

利用命题等价式可以分析（不是解决）许多有趣的问题：

<br>

> **问题1 $n$ 皇后问题**
>
> $n$ 皇后问题要求在一个 $n\times n$ 的棋盘上放置 $n$ 个皇后，目的是使皇后之间不能相互吃掉，这意味着没有两个皇后被放置在同一行、同一列或者同一对角线上

<br>

引入 $n^2$ 个变量 $p(i,j),1\leq i,j\leq n$，其含义如下：当在第 $i$ 行第 $j$ 列的格子上有皇后时，$p(i,j)$ 为真，否则为假。我们先断言每一行都只能有一个皇后，这可以通过说明每一行至少有一个皇后和每一行最多只有一个皇后来完成。

注意到 $\bigvee_{j=1}^np(i,j)$ 断言第 $i$ 行至少有一个皇后，于是每一行都至少有一个皇后可以由以下逻辑表达式断言：

$$
    Q_1=\bigwedge_{i=1}^n\bigvee_{j=1}^np(i,j)
$$

对于每一行最多包含一个皇后，则当整数 $k,j$ 满足 $1\leq j<k\leq n$ 时必须有 $p(i,j)$ 和 $p(i,k)$ 不同时为真，用逻辑表达式表述就是 $\lnot p(i,j)\vee\lnot p(i,k)$。于是检测每一行最多只有一个皇后可以由以下逻辑表达式断言：

$$
    Q_2=\bigwedge_{i=1}^n\bigwedge_{j=1}^{n-1}\bigwedge_{k=i+1}^n\lnot p(i,j)\vee\lnot p(i,k)
$$

保证每一列都最多只有一个皇后的断言如下：

$$
    Q_3=\bigwedge_{j=1}^n\bigwedge_{i=1}^{n-1}\bigwedge_{k=j+1}^n\lnot p(i,j)\vee\lnot p(k,j)
$$

注意到如果有 $i+i'=j+j'$ 或者 $i-i'=j-j'$ 成立，则说明 $(i,j)$ 和 $(i',j')$ 格子在对角线上，根据这个命题可以知道对角线上不得有多个皇后可以由以下逻辑表达式断言：

$$
    \begin{aligned}
    Q_4&=\bigwedge_{i=2}^n\bigwedge_{j=1}^{n-1}\bigwedge_{k=1}^{\min(i-1, n-j)}\lnot p(i,j)\vee\lnot p(i-k, k+j)\\
    Q_5&=\bigwedge_{i=1}^{n-1}\bigwedge_{j=1}^{n-1}\bigwedge_{k=1}^{\min(n-i,n-j)}\lnot p(i,j)\vee\lnot p(i+k,j+k)
    \end{aligned}
$$

对于 $n$ 皇后问题，这实际上就是要找到所有使得 $\bigwedge_{i=1}^5 Q_i$ 为真的 $p(i,j)$。但是以上步骤只是在分析问题，具体的解法需要借助其余知识。

<br>

> **问题2 数独**
>
> 数独可表示为一个 $9\times 9$ 格，它由 $9$ 个称为九宫格的 $3\times 3$ 子格组成。$81$ 个单元中的一部分被赋予 $1,\cdots,9$ 中的数字之一，称为已知单元。数独的目的是找出其余空着的未知单元应当填的数字，使得每一行、每一列、每个小九宫格都包含九个不同的数字。数独也可以推广到 $n^2\times n^2$ 格，由 $n^2$ 个 $n\times n$ 的子格组成

<br>

令 $p(i,j,n)$ 表示一个命题，当数 $n$ 位于第 $i$ 行和第 $j$ 列的单元时为真，一共有 $729$ 个这样的命题。数独的要求如下：
- 对于已知单元，当第 $i$ 行和第 $j$ 列的单元中是已知数 $n$ 时，断言 $Q_1=\bigwedge_{i,j,n} p(i,j,n)$；
- 每一行都包含了每一个数，断言

    $$
        Q_2=\bigwedge_{i=1}^9\bigwedge_{n=1}^9\bigvee_{j=1}^9p(i,j,n)
    $$

- 每一列都包含了每一个数，断言

    $$
        Q_3=\bigwedge_{j=1}^9\bigwedge_{n=1}^9\bigvee_{i=1}^9p(i,j,n)
    $$

- 每一个子格包含了每一个数，断言

    $$
        Q_4=\bigwedge_{r=0}^2\bigwedge_{s=0}^2\bigwedge_{n=1}^9\bigvee_{i=1}^3\bigvee_{j=1}^3p(3r+i,3s+j,n)
    $$

对于数独问题，实际上就是要找到所有使得 $\bigwedge_{i=1}^4Q_i$ 为真的 $p(i,j,n)$ 变量。

<br>

### 1.3 谓词和量词

<br>

> **定义 1.3-1 谓词（predicate）**
>
> 一般地，涉及 $n$ 个变量 $x_1,\cdots x_n$ 的语句可以表示成
> 
> $$
>   P(x_1,\cdots, x_n)
>   $$
>
> 形式为 $P(x_1,\cdots,x_n)$ 的语句是命题函数 $P$ 在 $n$ 元组 $(x_1,\cdots,x_n)$ 的值，$P$ 也称为 $n$ 位谓词或 $n$ 元谓词

<br>

当命题函数中的变量均被赋值时，所得到的语句变为某个具有真值的命题。量化表示在何种程度上谓词对于一定范围的个体成立：全称量化，一个谓词在所考虑范围内对每一个个体都为真；存在量化，一个谓词对所考虑范围内的一个或多个个体为真。
- 全称量词：命题为某一性质对于变量在某一特定域内的所有值均为真，这一特定领域称为变量的**论域**（domain of discource）或**全体域**（universe of discource）。

    > **定义 1.3-2 全称量化（universal quantification）**
    > 
    > $P(x)$ 的全称量化是命题「$P(x)$ 对 $x$ 在其论域的所有值为真」，符号表示为 $\forall xP(x)$，其中 $\forall$ 称为全称量词。一个使 $\forall xP(x)$ 为假的 $x$ 称为反例

- 存在量词：命题为某一性质对于变量在其某一特定域内至少一个值为真。

    > **定义 1.3-3 存在量化（existential quantification）**
    > 
    > $P(x)$ 的存在量化是命题「论域中存在一个个体 $x$ 满足 $P(x)$」，符号表示为 $\exists xP(x)$，其中 $\exists$ 称为存在量词

- 唯一性量词：符号表示为 $\exists_1$ 或者 $\exists!$，$\exists_1 xP(x)$ 和 $\exists!xP(x)$ 表示法是指「存在唯一的 $x$ 使得 $P(x)$ 为真」。

<br>

当一个量词的论域是有限的时候，即所有元素可以一一列出时，量化语句就可以用命题逻辑来表达。当论域中的元素为 $x_1,\cdots,x_n$，全称量化 $\forall xP(x)$ 与合取式 $\bigwedge_{i=1}^nP(x_i)$ 等价。

<br>

> **定义 1.3-4 涉及量词的逻辑等价式**
>
> 涉及谓词和量词的语句是逻辑等价的当且仅当无论用什么谓词代入这些语句，也无论为这些命题函数里的变量指定什么论域，它们都具有相同的真值。用 $S\Leftrightarrow T$ 表示涉及谓词和量词的两个语句 $S$ 和 $T$ 是逻辑等价的

<br>

经常需要对量化表达式进行否定，量词的否定规则又称为量词的 De Morgan 律：

$$
    \begin{aligned}
        \lnot\exists xP(x)&\Leftrightarrow\forall x\lnot P(x)\\
        \lnot\forall xP(x)&\Leftrightarrow\exists x\lnot P(x)
    \end{aligned}
$$

<br>

当一个量词出现在另一个量词的论域中时，称其为嵌套量词，例如语句 $\forall x\forall y\forall z(x+(y+z)=(x+y)+z)$。理解这种含有嵌套量词的方法是将其视作嵌套的循环，例如刚才的语句可以理解为一个三重的嵌套循环，分别对 $x,y,x$ 进行了遍历（当然对于论域中的元素是无限的情况，不能做到真正的遍历）。

<br>

### 1.4 推理与证明方法

<br>

> **定义 1.4-1 论证（argument）**
>
> 命题逻辑中的一个论证是一连串的命题，论证的最后一个命题称为结论，其余命题都称为前提。一个论证是有效的，如果它的所有结论为真蕴含着结论为真。
>
> 命题逻辑中的一个论证形式是一连串涉及命题变量的复合命题，无论用说明特定命题来替换其中的命题变量，如果前提均真是结论为真，则称该论证形式是有效的：当 $\bigwedge_{i=1}^np_i\rightarrow q$ 为永真式时，带有前提 $p_1,\cdots,p_n$ 以及结论 $q$ 的论证形式就是有效的

<br>

根据有效的论证形式的定义，从一些永真式里可以推导出有效论证形式：

<br>

|永真式|有效的论证形式|名称|
|:---:|:---:|:---:|
|$(p\wedge(p\rightarrow q)\rightarrow q)$|$(p,p\rightarrow q)\Rightarrow q$|假言推理|
|$(\lnot q\wedge(p\rightarrow q))\rightarrow\lnot p$|$(\lnot q,p\rightarrow q)\Rightarrow\lnot p$|取拒式|
|$(p\rightarrow q)\wedge(q\rightarrow r)\rightarrow r$|$(p\rightarrow q,q\rightarrow r)\Rightarrow (p\rightarrow r)$|假言三段论|
|$((p\vee q)\wedge\lnot p)\rightarrow q$|$(p\vee q,\lnot p)\Rightarrow q$|析取三段论|
|$p\rightarrow p\vee q$|$(p)\Rightarrow p\vee q$|附加律|
|$(p\wedge q)\rightarrow p$|$(p\wedge q)\Rightarrow p$|化简律|
|$((p)\wedge (q))\rightarrow p\wedge q$|$(p,q)\Rightarrow p\wedge q$|合取律|
|$((p\vee q)\wedge(\lnot p\vee r))\rightarrow(q\vee r)$|$(p\vee q,\lnot p\vee r)\Rightarrow q\vee r$|消解律|

<br>

含有量词的命题函数是我们关心的，以下有四个有关量词的有效论证形式：
- **全称实例**是从给定前提 $\forall xP(x)$ 得出 $P(c)$ 为真的推理规则，其中 $c$ 是论域里的一个成员；
- **全称引入**是从对论域里所有元素 $c$ 都有 $P(c)$ 为真的前提推出 $\forall xP(x)$ 的推理规则，这里所选择的元素 $c$ 必须是论域中任意的一个元素；
- **存在实例**是指如果我们知道 $\exists xP(x)$ 为真，得出在论域中存在一个元素 $c$ 使得 $P(c)$ 为真的推理规则；
- **存在引入**是由已知有一特定的 $c$ 使得 $P(c)$ 为真时得出 $\exists xP(x)$ 为真的推理规则。

<br>

#### 1.4.1 直接证明法

<br>

直接证明法是通过证明如果 $p$ 为真，那么 $q$ 也一定为真，这样 $p$ 为真而 $q$ 为假的情况就不会发生，从而说明了 $p\rightarrow q$ 为真，以下就是一个直接证明法的例子：

<br>

> **问题 1**
>
> 给出命题「如果 $n$ 是奇数，则 $n^2$ 是奇数」的直接证明

<br>

证明：当 $n$ 是奇数时，可以得到 $n=2k+1,k\in\mathbb{Z}$，此时 $n^2=(2k+1)^2=4k^2+4k+1=2(2k^2+2k)+1$，注意到其中 $2k^2+2k\in\mathbb{Z}$，因此 $n^2$ 也是一个奇数。根据全称引入的推理规则，可以得到命题成立（论域是正整数集）。

<br>

#### 1.4.2 反证法

<br>

反证法利用这样一个事实：$p\rightarrow q\Leftrightarrow\lnot q\rightarrow\lnot p$，这意味着条件语句 $p\rightarrow q$ 的证明可以通过其逆否命题 $\lnot q\rightarrow\lnot p$ 进行证明。用反证法时，我们将 $\lnot q$ 作为前提，证明 $\lnot p$ 必须成立，以下就是一个反证法的例子：

<br>

> **问题 2**
>
> 给出命题「如果 $n$ 是整数且 $n^2$ 是奇数，则 $n$ 是奇数」的反证证明

<br>

证明：由于直接证明法不能给出有效的论证形式，考虑反证法。设 $n$ 为偶数，则可以得到 $n=2k,k\in\mathbb{Z}$，此时 $n^2=4k^2=2(2k^2)$，其中 $2k^2$ 是整数，因此 $n^2$ 也是偶数。根据反证法可知命题成立。

<br>

#### 1.4.3 归谬证明法

<br>

要证明命题 $p$ 是真的，假定我们能找到一个矛盾式 $q$ 使得 $\lnot p\rightarrow q$ 为真。因为 $q$ 是假的，所以 $\lnot p$ 是假的，因此可以得到 $p$ 是真的。我们已经知道对于任意命题 $r$，复合命题 $r\wedge\lnot r$ 是矛盾式，所以如果能够证明存在某个命题 $r$ 使得 $\lnot p\rightarrow r\wedge\lnot r$ 为真，就能够证明 $p$ 为真了，这种证明方法被称为归谬证明法。以下就是一个归谬证明法的例子：

<br>

> **问题 3**
>
> 通过归谬证明法来证明 $\sqrt{2}$ 是无理数

<br>

证明：设命题 $p$ 是「$\sqrt{2}$ 是无理数」，假定 $\lnot p$ 为真，即意味着 $\sqrt{2}$ 是有理数，存在整数 $a,b$ 满足 $\displaystyle\sqrt{2}=\frac{a}{b}$，其中 $b\neq 0$ 并且 $a,b$ 没有公因数（此处用到了有理数都能写成既约分数的事实），于是

$$
    2=\frac{a^2}{b^2}\Leftrightarrow 2b^2=a^2
$$

注意到 $2b^2$ 是偶数，这意味着 $a^2$ 和 $a$ 都是偶数，此时 $a=2k,k\in\mathbb{Z}$，于是可以得到 $b^2=2k^2$，用相同的方法可以推出 $b^2$ 和 $b$ 都是偶数。这与 $a,b$ 没有公因数这一前提矛盾，根据归谬证明法可以得出 $\sqrt{2}$ 是无理数。

<br>

#### 1.4.4 存在性证明

<br>

有一些定理是形如 $\exists xP(x)$ 的命题。通过找到一个使 $P(a)$ 为真的元素 $a$ 来给出 $\exists xP(x)$ 为真的证明方法被称为构造性的（constructive）；不通过找到这样的 $a$，而是使用归谬证明，证明该量化式的否定蕴含着一个矛盾，以此说明存在性的证明方法被称为非构造性的。

<br>

> **问题 4 构造性的存在性证明**
>
> 证明存在一个正整数，可以用两种不同的方式将其表示为正整数的立方和

<br>

证明：存在 $1729=10^3+9^3=12^3+1^3$ 和 $4104=9^3+15^3=2^3+16^3$，故命题成立。这可以通过计算机来寻找，例如以下就是一个寻找 Taxicab 数的JavaScript程序：

<br>

``` javascript
function tuple(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
}
let searchSup = 10000;
let resultArray = [];
let count = 0;
for (let i = 1; i <= searchSup; i++) {
    for (let j = 1; j ** 3 <= i; j++) {
        let roughResult = Math.ceil((i - j ** 3) ** (1 / 3));
        for (let a = roughResult; a ** 3 + j ** 3 >= i && a > 0; a--) {
            if (a ** 3 + j ** 3 === i) {
                resultArray[count] = new tuple(a, j, i);
                count++;
            }
        }
    }
}
let search = 0;
for (let i = 0; i <= count - 1; i = search + 1) {
    search = i;
    let repeat = 0;
    while (search <= count - 1 &&
           resultArray[search].c === resultArray[i].c) {
        repeat++;
        search++;
    }
    if (repeat >= 4) {
        for (let j = i; j < search; j += 2) {
            console.log(`(${resultArray[j].a}, ${resultArray[j].b}, ${resultArray[j].c})`);
        }
    }
}
```

<br>

> **问题 5 非构造性的存在性证明**
>
> 证明存在无理数 $x$ 和 $y$ 使得 $x^y$ 为有理数

<br>

考虑数 $\sqrt{2}^{\sqrt{2}}$。如果它是有理数，则命题成立，这是因为 $\sqrt{2}$ 是无理数；如果它是无理数，构造 $(\sqrt{2}^{\sqrt{2}})^{\sqrt{2}} = (\sqrt{2})^2=2$ 为有理数，因此命题依旧成立。由这两种情况可知命题成立。

<br>

<br>

<br>

## 2 计数方法

<br>

### 2.1 计数的基本原理

<br>

> **命题 2.1-1 乘法原理**
>
> 假定一个过程可以被分解成两个任务。如果完成第一个任务有 $n_1$ 种方法，在第一个任务完成之后有 $n_2$ 种方法完成第二个任务，那么完成这个过程有 $n_1n_2$ 种方法。
>
> 可以将乘法原理进行推广，假定一个过程由执行任务 $T_1,\cdots,T_m$ 来完成，如果完成任务之后用 $n_i$ 种方式来完成任务 $T_i(i=1,\cdots,m)$，那么完成这个过程总共有 $n_1\times\cdots\times n_m$ 种方式

<br>

推广的乘法原理证明：考虑使用数学归纳法进行证明。当 $m=2$ 时，命题成立；假设命题对某个自然数 $m(m\geq 2)$ 成立，即完成所有任务 $T_1,\cdots,T_m$ 总共有 $n_1\times\cdots\times n_m$ 种方法；那么将前 $m$ 个任务看作一个独立的任务，同样可以得到对于所有任务 $T_1,\cdots,T_m,T_{m+1}$，完成这些任务总共有 $(n_1\times\cdots\times n_m)\times n_{m+1}$ 种方法。推广的乘法原理成立。

<br>

> **命题 2.1-2 加法原理**
>
> 完成一项任务有两类方法，第一类方法中有 $n_1$ 种方法，第二类方法中有 $n_2$ 种方法，则完成这项任务总共有 $n_1+n_2$ 种方法。
>
> 可以将加法原理进行推广，完成一项任务总共有 $m$ 类方式，第 $i$ 类方式中有 $n_i(i=1,\cdots,n)$ 种具体的方式，则完成这项任务总共有 $n_1+\cdots+n_m$ 种方式

<br>

与乘法原理相同，加法原理也可以使用数学归纳法证明：当 $m=2$ 时，命题成立；假设命题对某个自然数 $m(m\geq 2)$ 成立，即完成一项任务，若有 $m$ 类方式，且第 $i$ 类方式有 $n_i$ 种具体方式，则完成这个任务总共有 $n_1+\cdots+n_m$ 种方式；对于 $m+1$ 的情况，可以将前 $m$ 类方式都看作一类新的方式，因此完成这些任务总共有 $(n_1+\cdots+n_m)+n_{m+1}$ 种方式。推广的加法原理成立。推广的加法原理也可以用集合的语言描述：

$$
    \#\left(\bigcup_{i=1}^mA_i\right)=\sum_{i=1}^m\#(A_i),\quad 1\leq i,j\leq m,i\neq j,A_i\cap A_j=\emptyset
$$

<br>

> **命题 2.1-3 减法原理（容斥原理）**
>
> 如果一个任务或者可以通过 $n_1$ 种方法执行，或者可以通过 $n_2$ 种方法执行，那么完成这个任务的方法数是 $n_1+n_2$ 减去两类方法中相同的方法。容斥原理（principle of inclusion and exclusion）也可以用集合的语言描述：
>
> $$
    \#(A_1\cup A_2)=\#(A_1)+\#(A_2)-\#(A_1\cap A_2)
>    $$
>
> 容斥原理也具有推广形式，设 $A_1,\cdots,A_n$ 是有穷集，那么
>
> $$
    \begin{aligned}
    \#\left(\bigcup_{i=1}^nA_i\right)=\sum_{1\leq i\leq n}\#(A_i)&-\sum_{1\leq i<j\leq n}\#(A_i\cap A_j)\\
    +\sum_{1\leq i<j<k\leq n}\#(A_i\cap A_j\cap A_k)-&\cdots+(-1)^{n+1}\#(A_1\cap\cdots\cap A_n)
    \end{aligned}
>   $$

<br>

容斥原理的推广形式可以这样证明：通过证明并集的每个元素在等式右边恰好被计数 $1$ 次。假设 $a$ 恰好是 $A_1,\cdots,A_n$ 中 $r$ 个集合的成员，其中 $1\leq r\leq n$。这个元素被 $$ \sum\#(A_i) $$ 计数了 $\displaystyle\binom{r}{1}$ 次，被 $$ \sum\#(A_i\cap A_j) $$ 计数了 $\displaystyle\binom{r}{2}$ 次。一般地，涉及 $m$ 个 $A_i$ 集合的求和被计数了 $\displaystyle\binom{r}{m}$ 次。于是这个元素在等式右侧计数了

$$
    \binom{r}{1}-\binom{r}{2}+\binom{r}{3}+\cdots+(-1)^{r+1}\binom{r}{r}
$$

次，根据熟知的二项式定理（虽然在笔记里这是后面的内容）可知

$$
    (1+(-1))^r=\binom{r}{0}1^r+\binom{r}{1}1^{r-1}(-1)^1+\cdots+\binom{r}{r}(-1)^r
$$

因此可以得到计数次数恰好为 $1$，推广的容斥原理成立。

<br>

容斥原理有另一种表述形式，它在计数问题中比较常用，这种形式可以用于求解在一个集合中的元素数，使得这些元素不具有 $n$ 个性质 $P_1,P_2,\cdots,P_n$ 中的任意一条性质。设 $A_i$ 是具有性质 $P_i$ 的元素的子集，具有这些性质 $P_{i_1},P_{i_2},\cdots, P_{i_k}$ 的元素数记为 $N(P_{i_1}\cdots P_{i_k})$，用集合的语言描述就是

$$
    \#\left(\bigcap_{j=1}^kA_{i_j}\right)=N(P_{i_1}\cdots P_{i_k})
$$

如果将不具有 $n$ 个性质 $P_1,\cdots, P_n$ 中的任何一个的元素数记为 $N(\bar{P_1}\cdots\bar{P_n})$，那么根据容斥原理有

$$
    N(\bar{P_1}\cdots\bar{P_n})=N-\sum_{1\leq i\leq n}N(P_i)+\sum_{1\leq i<j\leq n}N(P_iP_j)
$$

$$
    -\sum_{1\leq i<j<k\leq n}N(P_iP_jP_k)+\cdots+(-1)^nN(P_1\cdots P_n)
$$

<br>

错位排列问题是使得没有一个物体在它的初始位置上的排列，它可以使用容斥原理求得，我们先给出错位排列数的表达式：

<br>

> **命题 2.1-4 错位排列数**
>
> $n$ 元素集合的错位排列数是
>
> $$
    D_n=n!\left[1-\frac{1}{1!}+\frac{1}{2!}+\cdots+(-1)^n\frac{1}{n!}\right]
>   $$

<br>

证明：如果排列保持了元素 $i$ 不变，则设排列有性质 $P_i$，错位排列数就是对 $i=1,\cdots,n$ 都没有性质 $P_i$ 的排列数，即

$$
    D_n=N(\bar{P_1}\cdots\bar{P_n})
$$

根据容斥原理

$$
    N(\bar{P_1}\cdots\bar{P_n})=N-\sum_{1\leq i\leq n}N(P_i)+\sum_{1\leq i<j\leq n}N(P_iP_j)
$$

$$
    -\sum_{1\leq i<j<k\leq n}N(P_iP_jP_k)+\cdots+(-1)^nN(P_1\cdots P_n)
$$

我们知道 $N(P_i)$ 表示的是保持 $i$ 元素不动，其余元素可以随意摆放的排列数，其值为 $(n-1)!$，同理我们知道 $N(P_iP_j)=(n-2)!$ 和 $N(P_iP_jP_k)=(n-3)!$，因此我们最终可以得到

$$
    \begin{aligned}
        D_n&=n!-\binom{1}{n}(n-1)!+\cdots+(-1)^n\binom{n}{n}0!\\
        &=n!-\frac{n!}{1!}+\frac{n!}{2!}+\cdots+(-1)^n\frac{n!}{n!}\\
        &=n!\left[1+\frac{1}{1!}-\frac{1}{2!}+\cdots+(-1)^n\frac{1}{n!}\right]
    \end{aligned}
$$

对于一个随机排列，其错位排列的概率是：

$$
    P_n=\frac{D_n}{n!}=1+\frac{1}{1!}-\frac{1}{2!}+\cdots+(-1)^n\frac{1}{n!}
$$

当 $n$ 趋向于无穷大时，根据 $\mathrm{e}^x$ 的生成函数

$$
    \mathrm{e}^x=1+x+\frac{1}{2!}x^2+\cdots=\sum_{k=0}^\infty \frac{x^k}{k!}
$$

知极限概率为

$$
    \lim_{n\to\infty}P_n=\lim_{n\to\infty}\left[1+\frac{1}{1!}-\frac{1}{2!}+\cdots+(-1)^n\frac{1}{n!}\right]=\frac{1}{\mathrm{e}}
$$

<br>

### 2.2 鸽巢原理

<br>

> **命题 2.2-1 鸽巢原理（pigeonhole principle）**
>
> 如果 $k+1$ 个或更多的物体放入 $k$ 个盒子，那么至少有一个盒子包含了 $2$ 个或者更多的物体

<br>

证明：使用反证法，假定 $k$ 个盒子中没有一个包含物体的数量多于 $1$ 个，那么物体总数至多是 $k$ 个，这与至少有 $k+1$ 个物体的前提矛盾。

<br>

> **命题 2.2-2 广义鸽巢原理**
>
> 如果 $N$ 个物体放入 $k$ 个盒子，那么至少有一个盒子包含了至少 $\displaystyle\left\lceil\frac{N}{k}\right\rceil$ 个物体

<br>

证明：使用反证法，假定没有盒子包含了比 $\displaystyle\left\lceil\frac{N}{k}\right\rceil-1$ 多的物体，那么物体总数至多是

$$
    k\left(\left\lceil\frac{N}{k}\right\rceil-1\right)<k\left(\left(\frac{N}{k}+1\right)-1\right)=N
$$

这与至少存在 $N$ 个物体的前提矛盾，根据反证法可知广义鸽巢原理成立。

<br>

> **问题**
>
> 证明：对每个整数 $n$，存在一个数是 $n$ 的倍数且在它的十进制中只出现 $0$ 和 $1$

证明：令 $n$ 是正整数，考虑 $n+1$ 个整数 $1,11,111,\cdots,\overbrace{1\cdots 1}^{n+1}$。注意到当一个整数被 $n$ 整除时存在 $n$ 个可能的余数，在给定的这 $n+1$ 的整数中，对 $n$ 进行整除操作，根据鸽巢原理可知必存在两个整数在整除 $n$ 时具有相同的余数。这两个整数之差的十进制表示中只有 $0$ 和 $1$ 且能被 $n$ 整除（因为它们的余数相同）。

<br>

上述构造方法只能给出存在性，如果需要求最小的满足条件的数，可以考虑构造一系列二进制串，判断能否整除 $n$，以下是这个思路的JavaScript程序：

<br>

``` javascript
let n = 121;
let testSup = 1023;
let flag = false;
for (let i = 1; i <= testSup && !flag; i++) {
    let binaryNum = i;
    let binaryStr = "";
    for (let j = 1; j <= Math.floor(Math.log2(i)) + 1; j++) {
        binaryStr = binaryNum % 2 + binaryStr;
        binaryNum = Math.floor(binaryNum / 2);
    }
    if (Number(binaryStr) % n === 0) {
        flag = true;
        console.log(binaryStr);
        console.log(Number(binaryStr) / n);
        break;
    }
}
```

<br>

### 2.3 排列组合

<br>

> **定义 2.3-1 排列（permutation）**
>
> 集合中不同元素的排列，是对这些元素的一种有序安排，而对一个集合中 $r$ 个元素进行排列的方式称为 $r$ 排列。具有 $n$ 个不同元素的集合的 $r$ 排列数是
>
> $$
    (n)_r=n(n-1)\cdots(n-r+1)=\frac{n!}{(n-r)!}
>   $$

<br>

> **定义 2.3-2 组合（combination）**
>
> 集合中不同元素的组合，是对这些元素的一种无序选取，而对一个集合中 $r$ 个元素进行组合的方式称为 $r$ 组合。具有 $n$ 个不同元素的集合的 $r$ 组合数是
>
> $$
    \binom{n}{r}=\frac{(n)_r}{(r)_r}=\frac{n!}{r!(n-r)!}
>   $$

<br>

排列组合有很多有意思的经典模型问题
- 有重复的排列：具有 $n$ 个物体的集合允许重复的 $r$ 排列数是 $n^r$；
- 有重复的组合：当允许重复时，$n$ 元素集合的每个 $r$ 组合可以用 $n-1$ 条竖线和 $r$ 个元素来表示。这 $n-1$ 条竖线用于标记 $n$ 个不同的单元，当集合的第 $i$ 个元素出现在组合中时，第 $i$ 个单元包含一个元素，例如 $4$ 元素集合的一个 $6$ 组合就可以用 $3$ 条竖线和 $6$ 个元素表示：`**|*||***`。这相当于在 $n+r-1$ 个位置中放入 $r$ 个元素的问题，故可重复的 $r$ 组合数为

    $$
        \binom{n+r-1}{r}=\binom{n+r-1}{n-1}
    $$

    一个比较有意思的等同于有重复组合的问题是如下的嵌套循环问题：

    ``` pseudocode
    k := 0
    for i_1 := 1 to n
        for i_2 := 1 to i_1
            ...
            for i_m := 1 to i_{m-1}
                k := k + 1
    ```

    执行上面的伪代码之后 $k$ 的值是 $\displaystyle\binom{n+m-1}{m}$，因为这本质上是寻找一个长度为 $m$ 的非递增序列，且所有元素都不超过 $n$。注意到任意从 $1,\cdots,n$ 中寻找 $m$ 个数（可重复），寻找到的 $m$ 个数都能经过降序排序得到一个非递增的序列，因此实际上选取是无序的，所以这等价于 $n$ 元素集的可重复 $m$ 组合问题。

- 具有部分不可区分物体集合的排列：设类型 $1$ 的相同的物体有 $n_1$ 个，类型 $2$ 的相同的物体有 $n_2$ 个，以此类推，类型 $k$ 的相同的物体有 $n_k$ 个，那么所有 $n$ 个物体的不同排列数是

    $$
        \frac{n!}{n_1!n_2!\cdots n_k!}
    $$

- 可辨别的物体放入可辨别的盒子：该问题等价于具有部分不可区分物体集合的排列问题，因为本质上不可区分的物体是排除了这些物体排列的可能，而放入盒子这一操作并不关心物体在盒子内的排列顺序，同样排除了排列的可能。把 $n$ 个不同的物体分配给 $k$ 个不同的盒子使得 $n_i$ 个物体放入盒子 $i$ 的方法数为

    $$
        \frac{n!}{n_1!n_2!\cdots n_k!}
    $$

- 不可辨别的物体放入可辨别的盒子：该问题等价于有重复的组合问题，这从此前使用过的竖线-元素模型中可以看出。把 $r$ 个不可辨别的物体放入 $n$ 个可辩别的盒子中的方法数是

    $$
        \binom{n+r-1}{r}=\binom{n+r-1}{n-1}
    $$

- 可辨别的物体放入不可辨别的盒子：该问题等价于一个集合划分为不相交的非空子集的问题。设 $S(n,j)$ 表示将 $n$ 个可辨别的物体放入 $j$ 个不可辨别的盒子的方法数，其中不允许有空的盒子。我们考虑与之类似的一个问题：从 $n$ 元素集到 $j$ 元素集的满射个数。假定值域中的元素为 $b_1,\cdots,b_j$，设性质 $P_i$ 表示元素 $b_i$ 不在映射值域内的性质，则该问题所求的是 $N(\bar{P_1}\cdots\bar{P_n})$，则根据容斥原理

    $$
        N(\bar{P_1}\cdots\bar{P_n})=\sum_{i=0}^{j-1}(-1)^i\binom{j}{i}(j-i)^n
    $$

    其中 $(j-i)^n$ 指的是从 $n$ 元素集合到 $j-i$ 元素集合的映射个数，$\displaystyle\binom{j}{i}$ 指的是从 $j$ 元素集剔除 $i$ 个元素的方法数。根据题意，集合内的元素是可辨别的，故 $S(n,j)$ 还需要 $N(\bar{P_1}\cdots\bar{P_n})$ 除以 $j$ 个元素的排列数：

    $$
        S(n,j)=\frac{1}{j!}\sum_{i=0}^{j-1}(-1)^i\binom{j}{i}(j-i)^n
    $$

    $S(n,j)$ 被称为**第二类 Stirling 数**。而将 $n$ 个可辨别的物体放入 $k$ 个不可辨别的盒子（允许有空）的方法数是

    $$
        \sum_{j=1}^kS(n,j)=\sum_{j=1}^k\frac{1}{j!}\sum_{i=0}^{j-1}(-1)^i\binom{j}{i}(j-i)^n
    $$

<br>

#### 2.3.1 生成排列算法

<br>

任何 $n$ 元素集合都可以与集合 $$ \{1,2,\cdots, n\}$$ 建立双射。我们可以构建算法按照字典顺序生成排列（字典顺序指，如果对于某个 $k(1\leq k\leq n)$，$a_1=b_1,a_2=b_2,\cdots,a_{k-1}=b_{k-1},a_k<b_k$，则排列 $a_1\cdots a_n$ 在排列 $b_1\cdots b_n$ 前面）。

<br>

生成排列的算法基础是从一个给定排列 $a_1\cdots a_n$ 按照字典顺序构造下一个排列的过程，可以描述一个一般的方法来生成下一个排列：
- 首先，找到整数 $j$ 使得 $a_j<a_{j+1}$ 且

    $$
        a_{j+1}>a_{j+2}>\cdots>a_n
    $$

    即找到这个排列中最后相邻的整数，使得这个对的第一个整数小于第二个整数；
- 然后，把 $a_{j+1},\cdots,a_n$ 中大于 $a_j$ 的最小整数放到第 $j$ 个位置；
- 再按照递增顺序从位置 $j+1$ 到 $n$ 列出 $a_j,a_{j+1},\cdots,a_n$ 中其余的整数。


<br>

> **算法 2.3-1 生成下一个排列**
>
> ``` pseudocode
> procedure | next permutation
> (a_1...a_n : {1,...,n})
> 
> j := n - 1
> while a_j > a_{j+1}
>     j := j - 1
> // j is the biggest subscript that permits a_j < a_{j+1}
> k := n
> while a_j > a_k
>     k := k - 1
> // a_k is the smallest integer, it is greater than a_j and is on the right of a_j
> SWAP(a_j, a_k)
> r := n
> s := j + 1
> while r > s
>     SWAP(a_r, a_s)
>     r := r - 1
>     s := s + 1
> ```

<br>

以下是根据该算法写出的生成所有排列的C++程序：

<br>

``` cpp
#include <iostream>
#include <string>

void swap(int* a, int* b);

int main() {
    int n = 6;
    int per[n];
    bool flag = false;
    std::string perStr = "";
    for (int i = 1; i <= n; i++) {
        per[i - 1] = i;
        perStr += std::to_string(per[i - 1]);
    }
    perStr += "\n";
    while (true) {
        int t = 0;
        while (t <= n - 1 && per[t] == n - t)
            t++;
        if (t == n)
            break;
        int j = n - 2;
        while (j >= 0 && per[j] > per[j + 1])
            j--;
        int k = n - 1;
        while (k >= 0 && per[j] > per[k])
            k--;
        swap(&per[j], &per[k]);
        int r = n - 1;
        int s = j + 1;
        while (r > s) {
            swap(&per[r], &per[s]);
            r--;
            s++;
        }
        for (int i = 1; i <= n; i++)
            perStr += std::to_string(per[i - 1]);
        perStr += "\n";
    }
    std::cout << perStr;
    return 0;
}

void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
```

<br>

#### 2.3.2 生成组合算法

<br>

一个有穷集的一个组合相当于它的子集，我们可以在集合 $$ \{a_1,\cdots,a_n\} $$ 的子集与 $n$ 位比特串之间建立双射关系。如果 $a_k$ 在子集中，对应的比特串在第 $k$ 位是 $1$，否则为 $0$。

<br>

生成组合的算法基础是找到按照字典顺序找到下一个比特串，可以描述一个一般的方法来生成下一个组合（本质上是进位）：
- 首先，找到整数 $j$ 使得 $a_j=0$ 且 $a_{j+1}=\cdots=a_n=1$；
- 将 $a_j$ 变为 $1$，$a_{j+1},\cdots,a_n$ 变为 $0$。

<br>

> **算法 2.3-2 生成下一个组合**
>
> ``` pseudocode
> procedure | next bit string
> 
> i := 0
> while b_i = 1
>     b_i = 0
>     i := i + 1
> b_i = 1
> ```

<br>

以下是根据该算法写出的生成所有组合的C++程序：

<br>

``` cpp
#include <iostream>
#include <string>

int main() {
    int n = 6;
    int com[n];
    std::string comStr = "";
    for (int i = 1; i <= n; i++) {
        com[i - 1] = 0;
        comStr += std::to_string(com[i - 1]);
    }
    comStr += "\n";
    while (true) {
        int t = 0;
        while (t <= n - 1 && com[t] == 1)
            t++;
        if (t == n)
            break;
        int i = 0;
        while (com[i] == 1) {
            com[i] = 0;
            i++;
        }
        com[i] = 1;
        for (int i = n; i >= 1; i--)
            comStr += std::to_string(com[i - 1]);
        comStr += "\n";
    }
    std::cout << comStr;
    return 0;
}
```

<br>

有时候我们需要给出的是集合的所有 $r$ 组合。根据之前讨论过的嵌套循环问题，我们知道一个 $r$ 组合可以表示成一个序列，这个序列按照递增的顺序（在前面的嵌套循环中是一个非递增，而这里是一个不可重复问题）包含了这个子集的元素，使用这些序列的字典顺序可以列出这些 $r$ 组合。在该字典顺序下，$$ \{1,\cdots, r\}$$ 是第一个组合， $$ \{n-r+1,\cdots,n\} $$ 是最后一个组合。

<br>

在 $r$ 组合 $a_1\cdots a_r$ 后面的下一个组合可以按照以下方法生成：
- 首先，找到最大的整数 $i$ 使得 $a_i\neq n-r+i$，其中 $n-r+i$ 就代表尾部元素的值；
- 然后，用 $a_i+1$ 代替 $a_i$，且对于 $j=i+1,\cdots,r$，用 $a_i+1+j-i$ 代替 $a_j$。第一步是逐渐将从头部过来的元素往尾部移动，第二步是将之前已经移动到尾部的元素向第一步移动的元素靠拢。

<br>

> **算法 2.3-3 生成下一个 $r$ 组合**
>
> ``` pseudocode
> procedure | next r-combination
> 
> i := r
> while a_i = n - r + i
>     i := i - 1
> // i is the smallest subscript that permits a_i != n - r + i
> a_i := a_i + 1
> for j := i + 1 to r
>     a_j := a_i + j - i
> // Here, a_i has already changed to a_i + 1
> ```

<br>

以下是根据该算法写出所有 $r$ 组合的C++程序：

<br>

``` cpp
#include <iostream>
#include <string>

int main() {
    int n = 6;
    int r = 4;
    int com[r];
    std::string comStr = ""; 
    for (int i = 1; i <= r; i++) {
        com[i - 1] = i;
        comStr += std::to_string(com[i - 1]);
    }
    comStr += "\n";
    while (true) {
        int t = 1;
        while (t <= r && com[t - 1] == n - r + t)
            t++;
        if (t == r + 1)
            break;
        int i = r;
        while (i >= 1 && com[i - 1] == n - r + i)
            i--;
        com[i - 1]++;
        for (int j = i + 1; j <= r; j++)
            com[j - 1] = com[i - 1] + j - i;
        for (int p = 1; p <= r; p++)
            comStr += std::to_string(com[p - 1]);
        comStr += "\n";
    }
    std::cout << comStr;
    return 0;
}
```

<br>

### 2.4 二项式

<br>

> **命题 2.4-1 二项式定理**
>
> 设 $x,y$ 是变量，$n$ 是非负整数，则
>
> $$
    (x+y)^n=\sum_{j=0}^n\binom{n}{j}x^{n-j}y^j
>   $$

<br>

这里给出二项式定理的组合学理解，$x^{n-j}y^j$ 可以理解为在 $n$ 个变量中设置 $j$ 个变量 $y$ 和 $n-j$ 个变量 $x$，方法数是 $\displaystyle\binom{n}{j}$，因此该展开式就是 $j$ 从 $0$ 到 $n$ 的和。

<br>

> **命题 2.4-2 Pascal 恒等式**
>
> 设 $n$ 和 $k$ 是满足 $n\geq k$ 的正整数，那么有
>
> $$
    \binom{n+1}{k}=\binom{n}{k-1}+\binom{n}{k}
>   $$

<br>

这里给出 Pascal 恒等式的组合学理解，假设 $T$ 是包含 $n+1$ 个元素的集合，令 $a$ 是 $T$ 的一个元素，令 $$ S:=T-\{a\} $$，$T$ 的基数为 $k$ 的子集有 $\displaystyle\binom{n+1}{k}$ 个。不包含 $a$ 的所有子集都是 $S$ 的子集，这部分子集个数为 $\displaystyle\binom{n}{k}$；包含 $a$ 的所有子集，其去除 $a$ 构成的集合是 $S$ 的子集，这部分子集个数为 $\displaystyle\binom{n}{k-1}$，因此有 Pascal 恒等式成立。

<br>

> **命题 2.4-3 Van der Monde 恒等式**
>
> 设 $m,n,r$ 为非负整数，其中 $r\leq m$ 或者 $r\leq n$，那么有
>
> $$
    \binom{m+n}{r}=\sum_{k=0}^r\binom{m}{k}\binom{n}{r-k}
>   $$

<br>

这里给出 Van der Monde 恒等式的组合学理解，假设 $T$ 是包含 $m+n$ 个元素的集合，其可以被划分为两个子集，第一个子集 $T_1$ 满足 $$ \#(T_1)=m $$，第二个子集 $T_2$ 满足 $$ \#(T_2)=n $$，从集合 $T$ 中选取 $r$ 个元素的方法数是 $\displaystyle\binom{m+n}{r}$。

我们可以从集合 $T_1$ 中取 $k$ 个元素，再从集合 $T_2$ 中取 $r-k$ 个元素，由乘法原理可知方法数为 $\displaystyle\binom{m}{k}\binom{n}{r-k}$，因此总方法数为

$$
    \sum_{k=0}^r\binom{m}{k}\binom{n}{r-k}
$$

<br>

### 2.5 递推

<br>

#### 2.5.1 递推问题

<br>

> **问题 1 汉诺塔问题**
>
> 汉诺塔由安装在一个板子上的 $3$ 根柱子和若干个大小不同的盘子组成。开始时，这些盘子按照大小的次序放在第一根柱子上，大盘子在底下。游戏的规则是：每一次把 $1$ 个盘子从一根柱子移动到另一根柱子上，但是不允许这个盘子放在比它小的盘子上面。游戏的目标是把所有的盘子按照大小次序都放到第二根柱子上，最大的盘子放在底部。
>
> ```
>     |                |               |
>    -+-               |               |
>   --+--              |               |
>  ---+---             |               |
> ----+----            |               |
> ```

<br>

首先需要明确的是，柱子之间并没有次序关系，它们是等价的（因为没有只能到达相邻柱子的要求）。用 $H_n$ 表示解 $n$ 个盘子的汉诺塔问题所需要的移动次数，开始时 $n$ 个盘子在柱 $1$。我们可以用 $H_{n-1}$ 次移动将上边的 $n-1$ 个盘子移动到柱 $3$（因为最大的盘子留在底部时对移动无影响），然后用一次移动将最大的盘子移动到柱 $2$，再用 $H_{n-1}$ 次移动将柱 $3$ 的 $n-1$ 个盘子移动到柱 $2$。则我们可以给出如下的递推关系：

$$
    H_n=2H_{n-1}+1
$$

初始条件是 $H_1=1$，令 $L_n=H_n+1$，很明显 $L_n$ 是一个等比数列，其首项为 $2$，公比为 $2$，于是 $L_n=2^n$，$H_n=2^n-1$。

<br>

> **问题 2 动态规划的一个实例**
>
> 设有 $n$ 场讲座，讲座 $j$ 开始于时间 $s_j$，结束于时间 $e_j$，有 $w_j$ 个学生参与，两个讲座不可以安排在同一时间，一个讲座可在另一个讲座结束时开始。我们需要规划最大的参与学生人数，即我们希望规划一个讲座安排使得在所有安排的讲座中 $w_j$ 之和最大

<br>

首先我们将这几个讲座按照结束时间升序排序并重新编号，满足 $e_1\leq\cdots\leq e_n$，我们称两个讲座之间是相容的，能够成为动态规划的一部分，当且仅当它们的时间不会重叠。对于第 $j$ 个讲座，定义 $\text{close}(j)$ 为满足 $e_i\leq s_j$ 的最大整数 $i$，即在时间表上，第 $i$ 个讲座的结束时间是在第 $j$ 个讲座开始时间之前最靠近的，如果不存在，则记 $\text{close}(j)=0$。以下就是一个事件表：

<br>

``` plaintext
7                       ▒▒▒▒▒▒▒▒    close(7) = 4
6              ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    close(6) = 2
5  ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒    close(5) = 0
4      ▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒              close(4) = 0
3           ▒▒▒▒▒▒▒                 close(3) = 1
2    ▒▒▒▒▒▒▒▒▒                      close(2) = 0
1 ▒▒▒▒▒▒▒▒                          close(1) = 0
```

<br>

设 $\text{best}(j)$ 表示由一个调度得到的前 $j$ 场讲座的学生最大参与数，则 $\text{best}(n)$ 就是我们最终需要求的答案。考虑前 $j$ 次讲座的学生参与调度，我们知道讲座 $\text{close}(j)+1,\cdots,j-1$ 不可能属于这个调度，因为它们与讲座 $j$ 是不相容的。
- 当讲座 $j$ 可以安排到前 $\text{close}(j)$ 个讲座的调度中时，此时最大参与数为 $\text{best}(j)=w_j+\text{best}(\text{close}(j))$；
- 当讲座 $j$ 安排不进前 $\text{close}(j)$ 个讲座的调度中时（这说明 $\text{close}(j)=0$），保持 $\text{best}(j)=\text{best}(j-1)$。

综合以上两种情形可以得到最终的递推形式：

$$
    \text{best}(j)=\max(w_j+\text{best}(\text{close}(j)),\text{best}(j-1))
$$

写作伪代码如下：

<br>

``` pseudocode
procedure | maximum attendees
s_1,...,s_n : The start time of lectures
e_1,...,e_n : The end time of lectures
w_1,...,w_n : The number of attendees

SORT(e_i, <)
for j := 1 to n
    if !E i(i < j) => e_i < s_j
        close(j) := 0
    else
        close(j) := MAXOF(i), i(i < j) => e_i < s_j
best(0) := 0
for j := 1 to n
    best(j) := MAX(w_j + best(close(j)), best(j - 1))
return best(n)
```

<br>

以下是根据该算法写出的C++程序：

<br>

``` cpp
#include <iostream>

struct lecture {
    int s;  // start time
    int e;  // end time
    int w;  // attendees
    int i;  // index
};

void swap(lecture& a, lecture& b);

int main() {
    int close[7];
    int best[7];
    lecture l[6] = {
        {8,  10, 23},
        {9,  18, 90},
        {12, 16, 45},
        {10, 17, 64},
        {9,  13, 26},
        {16, 18, 34}
    };
    for (int k = 0; k <= 5; k++)
        l[k].i = k;
    for (int j = 0; j <= 4; j++) {
        for (int k = 0; k <= 5 - j - 1; k++) {
            if (l[k].e > l[k + 1].e) {
                swap(l[k], l[k + 1]);
            }
        }
    }
    for (int j = 1; j <= 6; j++) {
        close[j] = 0;
        for (int k = 1; k <= 6; k++) {
            if (l[k - 1].e <= l[j - 1].s)
                close[j] = k;
        }
    }
    best[0] = 0;
    for (int j = 1; j <= 6; j++)
        best[j] = l[j - 1].w + best[close[j]] > best[j - 1] ?
            l[j - 1].w + best[close[j]] : best[j - 1];
    std::cout << best[6];
    return 0;
}

void swap(lecture& a, lecture& b) {
    int t1, t2, t3, t4;
    t1 = a.s; a.s = b.s; b.s = t1;
    t2 = a.e; a.e = b.e; b.e = t2;
    t3 = a.w; a.w = b.w; b.w = t3;
    t4 = a.i; a.i = b.i; b.i = t4;
}
```

<br>

#### 2.5.2 线性递推关系

<br>

> **定义 2.5-1 常系数线性齐次递推关系**
>
> 一个常系数的 $k$ 阶线性齐次递推关系是形如
>
> $$
    a_n=c_1a_{n-1}+\cdots+c_ka_{n-k}
>   $$
>
> 的递推关系，其中 $c_1,\cdots,c_k$ 是实数，$c_k\neq 0$

<br>

根据数学归纳法第二原理，这个序列由这个递推关系和 $k$ 个限制条件确定。根据经验，这些递推关系具有 $a_n=r^n(r\neq 0)$ 的解，其中 $r$ 是常数，当其为上述递推方程的解时有：

$$
    r^k-c_1r^{k-1}-c_2r^{k-2}-\cdots-c_k=0
$$

这个方程称为递推关系的特征方程，方程的解为该递推关系的特征根。

<br>

注意到，线性齐次递推关系的解的线性组合也是递推关系的解，所以可以找到一组基来表示 $a_n$。设上述特征方程分别有 $k$ 个不相同的根 $r_1,\cdots,r_k$，此时

$$
    a_n=\alpha_1r_1^n+\alpha_2r_2^n+\cdots+\alpha_kr_k^n
$$

其中 $\alpha_1,\cdots,\alpha_k$ 是待解的系数。

<br>

如果上述方程有 $t$ 个不相等的根 $r_1,\cdots,r_t$，其重根数为 $m_1,\cdots,m_t$，满足 $m_i\geq 1(i=1,\cdots,t)$，且 $m_1+\cdots+m_t=k$，此时

$$
    \begin{aligned}
        a_n=&(\alpha_{1,0}+\alpha_{1,1}n+\cdots+\alpha_{1,m_1-1}n^{m_1-1})r_1^n\\
        &+(\alpha_{2,0}+\alpha_{2,1}n+\cdots+\alpha_{2,m_2-1}n^{m_2-1})r_2^n\\
        &+\cdots+(\alpha_{t,0}+\alpha_{t,1}n+\cdots+\alpha_{t,m_t-1}n^{m_t-1})r_t^n
    \end{aligned}
$$

其中 $\alpha_{i,j}$，$1\leq i\leq t$ 和 $1\leq j\leq m_i-1$ 是待解的系数。

<br>

> **定义 2.5-2 常系数线性非齐次递推关系**
>
> 一个常系数的 $k$ 阶线性非齐次递推关系是形如
>
> $$
    a_n=c_1a_{n-1}+\cdots+c_ka_{n-k}+F(n)
>   $$
>
> 的递推关系，其中 $c_1,\cdots,c_k$ 是实数，$F(n)$ 是只依赖于 $n$ 且不恒为 $0$ 的函数。该递推关系具有一个相伴的齐次递推关系：
>
> $$
    a_n=c_1a_{n-1}+\cdots+c_ka_{n-k}
>   $$

<br>

如果 $a_n^{(p)}$ 是非齐次递推关系的一个特解，那么每个解都是 $a_n^{(p)}+a_n^{(h)}$ 的形式，其中 $a_n^{(h)}$ 是相伴的齐次递推关系的解。

<br>

### 2.6 生成函数

<br>

> **定义 2.6-1 生成函数**
>
> 对于一个实数序列 $a_0,a_1,\cdots,a_k,\cdots$ 的生成函数是无穷级数
>
> $$
    G(x)=a_0+a_1x+\cdots+a_kx^k+\cdots=\sum_{k=0}^\infty a_kx^k
>   $$

<br>

> **命题 2.6-1 生成函数之间的运算**
>
> 令 $f(x)=\sum_{k=0}^\infty a_kx^k$，$g(x)=\sum_{k=0}^\infty b_kx^k$，那么
>
> $$
    \begin{aligned}
        f(x)+g(x)&=\sum_{k=0}^\infty(a_k+b_k)x^k\\
        f(x)g(x)&=\sum_{k=0}^\infty\left(\sum_{j=0}^ka_jb_{k-j}\right)x^k
    \end{aligned}
>   $$

<br>

除了使用以上的加法和乘法运算给出新的生成函数，通过一个生成函数得到另一个生成函数的方法还有微分运算，例如我们知道

$$
    \frac{1}{1-x}=1+x+x^2+\cdots=\sum_{k=0}^\infty x^k
$$

两边求微分可以得到

$$
    \frac{1}{(1-x)^2}=1+2x+3x^2+\cdots=\sum_{k=0}^\infty(k+1)x^k
$$

<br>

> **定义 2.6-2 广义二项式系数**
>
> 设 $u$ 是实数且 $k$ 是非负整数，那么广义二项式系数 $\displaystyle\binom{u}{k}$ 定义为
>
> $$
    \binom{u}{k}=\begin{cases}
        \displaystyle\frac{u(u-1)\cdots(u-k+1)}{k!}&,k>0\\
        1&,k=0
    \end{cases}
>   $$

<br>

> **命题 2.6-2 广义二项式定理**
>
> 设 $x$ 是实数，$\lvert x\rvert<1$，$u$ 是实数，那么
>
> $$
    (1+x)^u=\sum_{k=0}^\infty\binom{u}{k}x^k
>   $$

<br>

生成函数的一个非常重要的作用就是可以用于解决计数问题，例如对于之前讨论过的当元素允许重复是 $n$ 元素集合的 $r$ 组合数公式：

设 $G(x)$ 是关于序列 $$ \{a_r\} $$ 的生成函数，其中 $a_r$ 等于 $n$ 元素集合的允许重复的 $r$ 组合数。当构成允许重复的 $r$ 组合时，对 $n$ 元素集合的元素选择不受限制，所以这 $n$ 个元素中的每一个元素都对 $G(x)$ 贡献了因子 $1+x+x^2+\cdots$，因为集合中有 $n$ 个元素：

$$
    G(x)=(1+x+x^2+\cdots)^n=\frac{1}{(1-x)^n},\;\lvert x\rvert<1
$$

根据广义二项式定理，有

$$
    \frac{1}{(1-x)^n}=(1-x)^{-n}=\sum_{r=0}^\infty\binom{-n}{r}(-x)^r
$$

根据广义二项式系数，有

$$
    \begin{aligned}
        (-1)^r\binom{-n}{r}&=(-1)^r\frac{(-n)(-n-1)\cdots(-n-r+1)}{r!}\\
        &=(-1)^r\frac{(-1)^rn(n+1)\cdots(n+r-1)}{r!}\\
        &=\frac{(n+r-1)!}{r!(n-1)!}\\
        &=\binom{n+r-1}{r}
    \end{aligned}
$$

<br>

生成函数的另一个重要作用是用于求解递推关系：设一个有效的码字是一个包含偶数个 $0$ 的十进制数字串，令 $a_n$ 表示 $n$ 位有效码字的个数。

首先我们需要给出这个问题的递推关系。对于 $n-1$ 位有效码字，我们可以在末尾添加一位非零数字来得到 $n$ 位有效码字，这样的方法有 $9a_{n-1}$ 种；对于 $n-1$ 位无效码字，我们可以在末尾添加一个 $0$ 来得到 $n$ 位有效码字，这样的方法有 $10^{n-1}-a_{n-1}$ 种，因此

$$
    a_n=8a_{n-1}+10^{n-1}
$$

设 $G(x)$ 是 $a_n$ 的生成函数，初始条件是 $a_1=9$，为了能进行生成函数的分析，根据递推关系我们可以得到 $a_0=1$，上述式子两边同时乘以 $x^n$ 得到：

$$
    a_nx^n=8a_{n-1}x^n+10^{n-1}x^n
$$

两边同时从 $1$ 开始做无穷级数求和：

$$
    \begin{aligned}
        G(x)-1&=\sum_{n=1}^\infty a_nx^n=\sum_{n=1}^\infty(8a_{n-1}x^n+10^{n-1}x^n)\\
        &=8\sum_{n=1}^\infty a_{n-1}x^n+\sum_{n=1}^\infty 10^{n-1}x^n\\
        &=8x\sum_{n=0}^\infty a_nx^n+x\sum_{n=0}^\infty (10x)^n\\
        &=8xG(x)+\frac{x}{1-10x}
    \end{aligned}
$$

由以上可得 $G(x)$ 的表示式及其生成函数：

$$
    \begin{aligned}
        G(x)&=\frac{1-9x}{(1-10x)(1-8x)}\\
        &=\frac{1}{2}\left(\frac{1}{1-10x}+\frac{1}{1-8x}\right)\\
        &=\frac{1}{2}\left(\sum_{n=0}^\infty 10^nx^n+\sum_{n=0}^\infty 8^nx^n\right)\\
        &=\sum_{n=0}^\infty\frac{1}{2}(8^n+10^n)x^n
    \end{aligned}
$$

因此根据以上分析可得 $\displaystyle a_n=\frac{1}{2}(8^n+10^n)$。

<br>

<br>

<br>

## 3 关系

<br>

### 3.1 关系及其性质

<br>

> **定义 3.1-1 集合的关系**
>
> 设 $A$ 和 $B$ 是集合，一个从 $A$ 到 $B$ 的二元关系是 Cartesian 积 $A\times B$ 的一个子集。即这个二元关系是一个集合 $R$，其中每个有序对的第一个元素取自 $A$ 而第二个元素取自 $B$。我们使用记号 $aRb$ 表示 $(a,b)\in R$，用 $a\cancel{R}b$ 表示 $(a,b)\notin R$

<br>

> **定义 3.1-2 集合上的关系**
>
> 集合 $A$ 上的关系是从 $A$ 到 $A$ 的关系，即是 Cartesian 积 $A\times A$ 的子集

<br>

对于 $n$ 元素集合 $A$，$A\times A$ 总共有 $n^2$ 个有序对，因此定义在 $n$ 元素集合上总共有 $2^{n^2}$ 个关系。

<br>

> **定义 3.1-3 自反性**
>
> 若对每个元素 $a\in A$ 有 $(a,a)\in R$，那么定义在集合 $A$ 上的关系 $R$ 是自反的（reflexive）；若对每个元素 $a\in A$ 有 $(a,a)\notin R$，那么定义在集合 $A$ 上的关系 $R$ 是反自反的（antireflexive）

<br>

对于 $n$ 元素集，如果定义在其上的关系 $R$ 是自反的，对于任意元素 $a\in A$，有序对 $(a,a)$ 一定在 $R$ 中。对于 $(a,b)$ 其中 $a\neq b$ 这样形式的有序对，总共有 $n(n-1)$ 个，它们可能在 $R$ 中也有可能不在，根据乘法原理可知一共存在 $2^{n(n-1)}$ 个自反的关系。反自反关系的计数过程和此类似，其个数也是 $2^{n(n-1)}$。

<br>

> **定义 3.1-4 对称性**
>
> 对于任意 $a,b\in A$，若只要 $(a,b)\in R$ 就有 $(b,a)\in R$，则称定义在集合 $A$ 上的关系 $R$ 是对称的（symmetric）。若对于任意 $a,b\in A$，若 $(a,b)\in R$ 且 $(b,a)\in R$，则一定有 $a=b$，则称定义在集合 $A$ 上的关系 $R$ 为反对称的（antisymmetric）

<br>

对于 $n$ 元素集，对称的有序对 $(a,b),(b,a)$，其中 $a\neq b$ 总共有 $\displaystyle\frac{n(n-1)}{2}$ 个，对于 $a=b$ 的自反有序对有 $n$ 个，因此所有的对称有序对有 $\displaystyle\frac{n(n+1)}{2}$ 个，对称关系总共有 $2^{n(n+1)/2}$ 个。

反对称不是对称的反义，对于只有 $(a,a)$ 的关系，它既是对称又是反对称的。我们来考虑反对称关系的个数，我们将 $n\times n$ 的所有关系表示成如下的矩阵（在之后会讲到矩阵表示关系的方法）：

$$
    \begin{pmatrix}
        1(0)& & & & \\
         &1(0)& & * & \\
         & & \ddots & & \\
         &* & & 1(0) &\\
         & & & & 1(0)\\
    \end{pmatrix}_{n\times n}
$$

只要选择了上三角中的某个有序对，就不能选择它对称处的有序对，对角线上的有序对不受影响，它们可出现在 $R$ 中也可不出现在 $R$ 中，总共有 $2^n$ 种选择。对于上三角和下三角的选择，设上三角和下三角元素的个数为 $\displaystyle r=\frac{n(n-1)}{2}$，我们可以得到

$$
    \begin{aligned}
        &\binom{r}{0}\sum_{j=0}^r\binom{r}{j}+\binom{r}{1}\sum_{j=0}^{r-1}\binom{r-1}{j}+\cdots+\binom{r}{r}\\
        &=\binom{r}{0}2^r+\binom{r}{1}2^{r-1}+\cdots+\binom{r}{r}2^0\\
        &=(1+2)^r\\
        &=3^{n(n-1)/2}
    \end{aligned}
$$

综上所述，反对称关系总共有 $2^n\times 3^{n(n-1)/2}$ 种。

<br>

> **定义 3.1-5 传递性**
>
> 对于任意 $a,b,c\in A$，$(a,b)\in R$ 并且 $(b,c)\in R$ 则 $(a,c)\in R$，那么定义在集合 $A$ 上的关系 $R$ 称为传递的（transitive）

<br>

$n$ 元素集的满足传递性的关系个数暂时没有发现闭公式，截止 2024-03-29，只给出了 $0\leq n\leq 18$ 时的关系数，具体可见 [OEIS-A006905](https://oeis.org/A006905)。

<br>

由于关系实际就是有序对的集合，因此关系之间也同样有集合间的运算。关系还具有一种合成运算，与映射的复合运算相似：

<br>

> **定义 3.1-6 关系的合成**
>
> 设 $R$ 是从集合 $A$ 到集合 $B$ 的关系，$S$ 是从集合 $B$ 到集合 $C$ 的关系。$R$ 与 $S$ 的合成是由有序对 $(a,c)$ 的集合构成的关系，其中 $a\in A,c\in C$，并且存在一个 $b\in B$ 的元素，使得 $(a,b)\in R$ 并且 $(b,c)\in R$。用 $S\circ R$ 表示 $R$ 与 $S$ 的合成

<br>

> **定义 3.1-7 关系的自身合成**
>
> 设 $R$ 是集合 $A$ 上的关系。 $R$ 的 $n$ 次幂 $R^n(n=1,\cdots,n)$ 递归地定义为
>
> $$
    R^1=R,\; R^{n+1}=R^n\circ R
>   $$

<br>

> **命题 3.1-1 传递关系的幂是该关系的子集**
>
> 设集合 $A$ 上的关系 $R$ 是传递的，当且仅当对 $n=1,2，3，\cdots$ 有 $R^n\subseteq R$

<br>

证明：
- 充分性：假设对 $n=1,2,3,\cdots$ 有 $R^n\subseteq R$，特别地有 $R^2\subseteq R$。注意若 $(a,b)\in R$ 且 $(b,c)\in R$，则 $(a,c)\in R^2$，因为 $R^2\subseteq R$，故 $(a,c)\in R$，于是 $R$ 具有传递性；
- 必要性：使用归纳法证明，当 $n=1$ 时命题成立；假设 $R^n\subseteq R$，其中 $n$ 是正整数；假设 $(a,b)\in R^{n+1}$，则因为 $R^{n+1}=R^n\circ R$，所以存在元素 $x\in A$ 使得 $(a,x)\in R$，$(x,b)\in R^n$，根据归纳假设知 $(x,b)\in R$，由传递性知 $(a,b)\in R$，因此 $R^{n+1}\subseteq R$。

<br>

### 3.2 关系的表示

<br>

可以用 $0/1$ 矩阵表示一个有穷集之间的关系，设 $R$ 是从 $$ A=\{a_1,\cdots,a_m\} $$ 到 $$ B=\{b_1,\cdots,b_n\} $$ 的关系，关系 $R$ 可以用矩阵 $\mathbf{M}_R=\left[m_{ij}\right]$ 来表示：

$$
    m_{ij}=\begin{cases}
        1&(a_i,b_j)\in R\\
        0&(a_i,b_j)\notin R
    \end{cases}
$$

当 $a_i,b_j$ 有关系时表示 $R$ 的 $0/1$ 矩阵