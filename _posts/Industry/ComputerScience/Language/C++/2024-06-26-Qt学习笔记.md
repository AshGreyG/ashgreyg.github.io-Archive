---
title: Qt学习笔记
author: AshGrey
date: 2024-06-26 00:00:00 +0800
categories: [Coumputer Science, Language]
tags: [Computer Science, C++]
excerpt: 本文章所属领域：实践产业知识 - 工业产业 - 计算机科学 - 编程语言 - C++
---


<br>

> 本文章所属领域：
>
> [实践产业知识 - 工业产业 - 计算机科学 - 编程语言 - C++]({% post_url /Computer Science/2024-02-08-计算机科学：索引笔记 %})
>
> 本文章所需前置知识：
>
> - [C++基础知识]({% post_url /Computer Science/Language/2024-02-08-C++基础知识笔记 %})
> - [Lambda表达式]({% post_url /Computer Science/Language/2024-06-30-Lambda表达式 %})
{: .prompt-info}

<br>

> **Q1 Qt 的信号槽使用方法是怎么样的？**

<br>

所谓的信号槽就是观察者模式，比如按钮检测到自己被点击了一下，它就会发出一个信号（signal），这种信号的发出类似广播，如果有对象对这个信号感兴趣，它就可以使用连接（connect）函数用自己的一个函数成为一个槽（slot）来处理这个信号。当信号发出时，被连接的槽函数就会被自动回调。例如下面的代码：

<br>

``` cpp
#include <QApplication>
#include <QPushButton>

int main(int argc, char *argv[]) {
    QApplication testApp(argc, argv);
    QPushButton testButton("Quit");
    QObject::connect(&testButton,
                     &QPushButton::clicked,
                 //  &testApp,
                     &QApplication::quit);
    return testApp.exec();
}
```

<br>

`QObject::connect`函数最常用的一般形式是：

<br>

``` cpp
QObject::connect(sender, signal, receiver, slot);
```

<br>

事实上上述代码中注释掉的参数补回去就满足这个一般形式了，我们将整个程序`testApp`作为接受信号的对象，其函数`QApplication::quit`作为槽函数。之所以上述代码能通过运行，是因为在 Qt5 中连接函数存在五个重载：

1. 重载函数1

    ``` cpp
    QMetaObject::Connection connect(const QObject*,
                                    const char*,
                                    const QObject*,
                                    const char*,
                                    Qt::ConnectionType);
    ```

    这里最后一个参数是有默认值`Qt::AutoConnection`，所以我们一般不用管最后一个参数，这就是我们上面提到的最常用的一般形式。发送信号和接受信号的对象的类型是`const QObject*`指针，所以我们需要使用`&`进行取地址，这个函数将信号函数和槽函数都当作字符串处理；

2. 重载函数2

    ``` cpp
    QMetaObject::Connection connect(const QObject*,
                                    const QMetaMethod&,
                                    const QObject*,
                                    const QMetaMethod&,
                                    Qt::ConnectionType);
    ```

    在这里我们可以将信号函数和槽函数都看作`QMetaMethod`的子类，这样做可以使用`QMetaMethod`进行类型比对；

3. 重载函数3

    ``` cpp
    QMetaObject::Connection connect(const QObject*,
                                    const char*,
                                    const char*,
                                    Qt::ConnectionType) const;
    ```

    这里缺少了`receiver`，当槽函数是`static`的时候，默认使用`this`指针作为`receiver`，我们上面写的代码中`QAppliction::quit`就是静态函数；

4. 重载函数4

    ``` cpp
    QMetaObject::Connection connect(const QObject*,
                                    PointerToMemberFunction,
                                    const QObject*,
                                    PointerToMemberFunction,
                                    Qt::ConnectionType);
    ```

    这里的`PointerToMemberFunction`就是指向成员函数的指针；

5. 重载函数5

    ``` cpp
    QMetaObject::Connection connect(const QObject*,
                                    PointerToMemberFunction,
                                    Functor);
    ```

    这里最后一个参数`Functor`接受静态函数、全局函数和 Lambda 表达式，例如以下的代码：

    ``` cpp
    #include <QApplication>
    #include <QPushButton>
    #include <iostream>

    int main(int argc, char *argv[]) {
        QApplication testApp(argc, argv);
        QPushButton testButton("Quit");
        QObject::connect(&testButton,
                         &QPushButton::clicked,
                         [] (bool) {
                            std::cout << "testButton is clicked.";
                            QApplication::quit();
                        });
        testButton.show();
        return testApp.exec();
    }
    ```

<br>

> **Q2 Qt 如何自定义信号槽？**

<br>

信号槽机制是一种设计模式，当然可以不止在 Qt 已定义的类中使用，程序员也可以自己定义带有信号槽机制的类，我们定义一个发出信号的类`TestSender`和一个接收信号的类`TestRecevier`。注意只有继承自`QObject`的类才有信号槽机制可以使用，并且需要在类的开头使用宏`Q_OBJECT`。

<br>

Qt 自定义了一个类似于访问控制`private`、`public`和`protected`关键字的宏`signals`，其后跟着的就是信号函数，信号函数不能具有实现，只能有函数原型（在 C++ 中没有实现的函数是会编译错误的，Qt 利用宏为我们的信号函数生成了实现）。在类的成员函数中，如果要发出这个信号，就需要使用宏`emit`：

<br>

``` cpp
class TestSender : public QObject {
    Q_OBJECT
private:
    std::string _name;
public:
    TestSender(std::string str) : _name(str) {}
    void send() {
        emit TestSenderSignal(_name);
    }
signals:
    void TestSenderSignal(const std::string& str);
};
```

<br>

我们再自定义一个普通的类，接着使用信号槽机制将这个类的成员函数作为槽函数：

<br>

``` cpp
class TestReceiver : public QObject {
    Q_OBJECT
public:
    TestReceiver() = default;
    void TestReceiverSignal() {
        std::cout << "I have received the signal from a sender";
    }
};
```

<br>

``` cpp
int main(int argc, char *argv[]) {
    QApplication testApp(argc, argv);
    QMainWindow testWindow;
    TestSender testSendObj("test");
    TestReceiver testReceiveObj;
    QObject::connect(&testSendObj,
                     &TestSender::TestSenderSignal,
                     &testReceiveObj,
                     &TestReceiver::TestReceiverSignal);
    testSendObj.send();
    testWindow.show();
    return testApp.exec();
}
```

<br>

> **Q3 什么是动作？怎么实现 Qt 中的动作？**

<br>

Qt 使用`QAction`类作为动作，这个类就是代表了窗口的一个「动作」，例如显示菜单，当用户点击该菜单项时，对用户的点击做出响应，当然也可能显示工具栏作为一个工具栏菜单项对用户的点击做出响应，但是无论是出现什么控件去响应用户的点击，做出的动作都应该是一样的，所以 Qt 抽象出公共的动作类`QAction`。当我们把`QAction`对象添加到菜单中时，就成为了一个菜单项，添加到工具栏中时，就成为了一个工具栏项。

<br>

一般来说，传统的 Qt 代码对于`QAction`类都是使用`new`来生成的，我测试了使用 C++ 标准库的智能指针来管理`QAction`类的对象的生命周期，发现图片无法正常加载，所以还是按照传统的 Qt 代码来写（Qt 应该有智能指针），注意我们在析构函数里也不需要对`QAction`对象手动删除：

<br>

``` cpp
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    setWindowTitle(tr("Main Window"));
    openAction = new QAction(QIcon(":/main/image-0"), tr("&Open..."), this);
    openAction->setShortcuts(QKeySequence::Open);
    openAction->setStatusTip(tr("Open an existing file"));
    QObject::connect(openAction,
                     &QAction::triggered,
                     this,
                     &MainWindow::open);

    QMenu* file = menuBar()->addMenu(tr("&File"));
    file->addAction(openAction);

    QToolBar* toolBar = addToolBar(tr("&File"));
    toolBar->addAction(openAction);
    statusBar();
}

void MainWindow::open() {
    QMessageBox::information(this, tr("Information"), tr("open"));
}

MainWindow::~MainWindow() {
    delete ui;
}
```

<br>

上面的`tr`函数都是 Qt 用于文本国际化的。`QAction`的三个构造函数如下，其中`QIcon`对象中的字符串表示图片文件在资源文件`.qrc`中的路径（不是真实的系统文件路径）。`QAction`对象构造函数中的字符串中的`&`意味着其后的字母成为快捷键（在 Windows 系统上`Alt`键按住时文本前面有下划线标注）：

<br>

``` cpp
explicit QAction(QObject *parent = nullptr);
explicit QAction(const QString &text,
                 QObject *parent = nullptr);
explicit QAction(const QIcon &icon,
                 const QString &text,
                 QObject *parent = nullptr);
```

<br>

这里的`connect`函数将`QAction`对象的信号`triggerd()`与`MainWindow`对象的`open()`槽函数链接起来了。其余具体的控件有`addAction()`函数，可以将控件和具体的动作链接起来。

<br>

> **Q4 什么是 Qt 的 moc 机制？Qt 的对象模型是怎么样的？**

<br>

Qt 扩展了 C++ 的语法，实际就是在使用标准 C++ 编译器编译 Qt 源程序之前，Qt 先使用一个叫做 moc（Meta Object Compiler，元对象编译器）的工具对源代码进行预处理，生成标准 C++ 代码，然后再用 C++ 标准编译器进行编译。例如信号函数不需要实现的这个语法就是因为 moc 会自动为信号函数生成实现。

<br>

`QObject`是以对象树的形式组织起来的，当创建一个`QObject`对象时，会看到`QObject`的构造函数接收一个`QObject`指针作为参数，这个参数就是`parent`，称其为**父对象指针**。在创建`QObject`对象时，可以提供一个其父对象，创建的这个对象自动添加到父对象的`childern()`列表中，当父对象析构时，子对象列表也会析构。这种对象模型在 GUI 中非常常用，例如一个按钮有`QShortcut`对象，当按钮被析构时，`QShortcut`对象也应该被析构，这是合理的。

<br>

> **Q5 怎么使用 Qt 的布局管理器？**

<br>

Qt 提供了几种布局管理器供我们选择：

- `QHBoxLayout`：按照水平方向从左到右布局；
- `QVBoxLayout`：按照竖直方向从上到下布局；
- `QGridLyout`：在一个网格中布局，类似 HTML 中的 table；
- `QFormLayout`：按照表格布局，每一行前面是一段文本，文本后面跟随一个组件；
- `QStackedLayout`：层叠的布局，允许将几个组件按照 z 轴方向堆叠，形成类似安装向导那样的一页一页的效果。

<br>

我们也可以使用`QBoxLayout`类，在构造函数中使用布局的方向：

<br>

``` cpp
int main(int argc, char *argv[])
{
    QApplication testApp(argc, argv);
    QWidget testWindow;
    testWindow.setWindowTitle(QObject::tr("Enter your height"));
    testWindow.setBackgroundRole(QPalette::Window);

    QSpinBox* testSpinBox = new QSpinBox(&testWindow);
    testSpinBox->setRange(100, 200);

    QSlider* testSlider = new QSlider(Qt::Horizontal, &testWindow);
    testSlider->setRange(100, 200);

    QObject::connect(testSlider,
                     &QSlider::valueChanged,
                     testSpinBox,
                     &QSpinBox::setValue);
    QObject::connect(testSpinBox,
                     &QSpinBox::valueChanged,
                     testSlider,
                     &QSlider::setValue);
    testSpinBox->setValue(180);

    QBoxLayout* testLayout = new QBoxLayout(QBoxLayout::LeftToRight,
                                            &testWindow);
    testLayout->addWidget(testSpinBox);
    testLayout->addWidget(testSlider);
    testWindow.setLayout(testLayout);

    testWindow.show();

    return testApp.exec();
}
```

<br>

