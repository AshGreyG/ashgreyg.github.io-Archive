---
title: C++语言律师：表达式
author: AshGrey
date: 2024-04-29 00:00:00 +0800
categories: [Coumputer Science, Language]
tags: [Computer Science, C++]
---

> 本文章所属领域：
>
> [实践产业知识 - 工业产业 - 计算机科学 - 编程语言 - C++]({% post_url /Computer Science/2024-02-08-计算机科学：索引笔记 %})
>
> 本文章所需前置知识：
>
> - [C++基础知识]({% post_url /Computer Science/Language/2024-02-08-C++基础知识笔记 %})
{: .prompt-info}

<br>

## 1 运算符

<br>

### 1.1 赋值运算符

<br>

赋值运算符（assignment）修改对象的值，对于非类类型，复制赋值和移动赋值没有区别（我们将在类的「语言律师」篇章中探讨），统称为**简单赋值**，都是将赋值运算符的右操作数替换左操作数的作用；复合赋值以左操作数和右操作数的二元运算结果替换左操作数内容。

<br>

赋值运算符的语法如下：

<br>

``` plaintext
target-expr = new-value     (1)
target-expr op new-value    (2)
op can be : 
*=  /=  %=  +=  -=  <<= >>= &=  ^=  |=
```

<br>

- 目标表达式（target-expr）：要被赋值的表达式，该表达式的优先级必须高于赋值运算符的优先级；
- 运算符（op）：`*=`（乘法赋值）、`/=`（除法赋值）、`%=`（取模赋值）、`&=`（逐位与赋值）、`|=`（逐位或赋值）、`^=`（逐位异或赋值）、`<<=`（逐位左移赋值）、`>>=`（逐位右移赋值）；
- 新值（new-value）：要赋值给目标的表达式（C++11 前）/初始化器子句（见篇章「初始化」，C++11 起）。

<br>

对于内建的简单赋值，目标表达式指代的对象会通过以新值的结果进行覆盖而被修改，这要求目标表达式必须是可修改的左值。内建的简单赋值构成的表达式的类型与目标表达式相同，并且指代目标表达式的左值。

<br>

如果新值是表达式，那么

<br>

<br>

<br>

## 2 值类别

<br>

C++表达式是带有操作数的操作符、字面量和变量名等，每个表达式都具有两种独立的特性：类型和值类别（value category），且都只属于三种基本值类别中的一种：**纯右值**（prvalue）、**亡值**（xvalue）和**左值**（lvalue）。

<br>

### 2.1 左值

<br>

下列表达式是左值表达式：

1. 变量、函数、模板形参对象或数据成员，不论类型。即使变量的类型是右值引用，由它的名字构成的表达式依然属于左值表达式；

    ``` cpp
    void fa() {}
    void fb() {
        void (*p)() = &fa;
        // 函数 fa 是左值，可以使用内建取地址运算符获取其地址
    }
    ```

2. 返回类型是左值引用的函数调用或者重载的运算符表达式，例如返回类型为`basic_stream&`（左值引用）的函数调用`std::getline(std::cin, str)`和返回类型为`ostream&`的重载运算符表达式`std::cout << 1`；

    ``` cpp
    int& a_ref() {
        static int a = 3;
        return a;
    }

    int main() {
        a_ref() = 5;
        std::cout << a_ref();
        // 函数调用 a_ref() 是左值，此函数调用的返回类型是左值引用
        return 0;
    }
    ```

3. `a = b`、`a += b`，以及所有其他内建的赋值或者复合赋值表达式；
4. `++a`和`--a`，内建的前置自增和前置自减表达式；
5. `*p`，内建的间接寻址表达式（内建间接寻址运算符的操作数必须是对象指针或者函数指针，它的结果就是表达式指向的对象或者函数）；
6. `a[n]`和`n[a]`，内建的下标表达式；
7. `a.m`，对象成员表达式。有两种情况下其不是左值，一是`m`是成员枚举项或非静态成员函数，二是`a`是右值而`m`是对象类型的非静态数据成员；

    ``` cpp
    struct foo {
        enum bar {
            m = 1,
            n = 2
        };
        void fun1() {}
        static void fun2() {}
    };

    int main() {
        foo a;
        a.m = 42;
        // ^^^^ error: lvalue required as left operand of assignment
        // 非良构，a.m 是纯右值，需要左值作为赋值运算符的左操作数
        void (foo:: *p1)() = &a.fun1;
        //                   ^^^^ 
        // error: ISO C++ forbids taking the address of a bound member function to form a pointer to member function
        // 非良构，a.fun1 是纯右值，不能以内建取地址运算符获取其地址
        void (foo:: *p2)() = &foo::fun1;
        // OK : 成员函数指针
        void (foo:: *p3)() = &a.fun2;
        // OK : a.fun2 不属于上述提到的两种情况，是左值，因此可以取地址
        void (foo:: *p4)() = &foo::fun2;
        // OK : 成员函数指针
        return 0;
    }
    ```

8. `p->m`，内建的指针成员表达式，由于其与`(*p).m`严格等价，且`*p`为左值，因此只有当`m`是成员枚举项或者非静态成员函数时才是例外情况；
9. `a.*mp`，对象的成员指针表达式，其中`a`是左值，`mp`是数据成员指针；
10. `p->*mp`，内建的指针的成员指针表达式，由于其与`(*p).*mp`严格等价，且`*p`为左值，因此不存在例外情况；
11. 字符串字面量，例如`"I love Sagiri"`；
12. 转换到左值引用类型的转型表达式，例如`static_cast<int&>(x)`；
13. 从 C++11 起，转换到函数的右值引用类型的转型表达式，例如`static_cast<void (&&)(int)>`；
14. 从 C++11 起，返回类型是到函数的右值引用的函数调用表达式或者重载的运算符表达式；
15. 具有左值引用类型的非类型模板形参：

    ``` cpp
    template <int& v>
    void set() {
        v = 5;  // 模板形参为左值
    }
    ```

<!-- TODO : 需要继续学习上述这些表达式的作用以及细节-->

<br>

左值具有以下的性质：

1. 可以通过内建的取值运算符取左值的地址，例如以下语句输出的是对象`std::cout`的地址：

    ```cpp
    std::cout << &std::cout;
    ```

2. 可修改的左值可用作内建赋值和内建复合赋值运算符的左操作数；
3. 左值可以用于初始化左值引用，这将新名字关联给该表达式所标识的对象；
4. 具有泛左值的性质。

<br>

### 2.2 纯右值

<br>

下列表达式是纯右值表达式：

1. 除了字符串字面量以外的其余数据类型字面量；
2. 返回类型是非引用的函数调用或重载运算符表达式；
3. `a++`和`a--`，内建的后置自增与后置自减表达式；
4. `a + b`、`a % b`，以及其他所有内建的算术表达式；
5. `a && b`、`a || b`、`!a`，内建的逻辑表达式；
6. `a < b`、`a == b`，以及其他所有内建的比较表达式；
7. `&a`，内建的取地址表达式；
8. 转换到非引用类型的转型表达式，例如`static_cast<double>(x)`；
9. `this`指针；
10. 枚举项；
11. 具有标量类型的非类型模板形参：

    ``` cpp
    template <int v>
    void foo() {
        const int* a = &v;
        //            ^^^^
        // error: lvalue required as unary '&' operand
        // 非良构，纯右值不能使用内建的取地址运算符
        v = 3;
        // ^^^
        // Expression is not assignable
        // 纯右值不能作为赋值运算符的左操作数
    }
    ```

12. lambda表达式；
13. requires表达式；
14. 概念的特化。

<!-- TODO : 需要继续学习后面几种概念-->

<br>

纯右值具有以下的性质：

1. 纯右值不具有多态：它所标识的对象的动态类型始终是该表达式的类型；

    注：声明或继承了至少一个虚函数的类类型的对象是多态对象，每个多态对象中，实现都会存储额外的信息，它被用于进行虚函数的调用。对于非多态对象，值的解释方式由使用对象的表达式所确定，这在编译期就已经决定。

    ``` cpp
    #include <iostream>
    #include <typeinfo>

    struct Base1 {
        virtual ~Base1() {}
    };
    struct Derived1 : Base1 {};
    struct Base2 {};
    struct Derived2 : Base2 {};

    int main() {
        Derived1 obj1;
        Derived2 obj2;
        Base1& p1 = obj1;
        Base2& p2 = obj2;
        std::cout << typeid(decltype(p1)).name() << "\n"
                  << typeid(decltype(p2)).name() << "\n"
                  << typeid(p1).name() << "\n"
                  << typeid(p2).name() << "\n"
                  << sizeof p1 << "\n"
                  << sizeof p2 << "\n";
        return 0;
    }
    ```

    其输出为：

    ``` plaintext
    5Base1
    5Base2
    8Derived1
    5Base2
    8
    1
    ```

    如果某个泛左值表达式指代某个多态对象，那么它的最终派生对象的类型被称为它的动态类型；

2. 非类非数组的纯右值不能有 cv-限定符，除非它被实质化以绑定到 cv-限定类型的引用上；

    注：cv-限定符指的是`const`和`volatile`类型限定符，它们可以出现在任何类型说明符中，以指定被声明对象或被命名类型的常量性（constness）或易变性（volatility）；实质化指的是临时量实质化，任何完整类型 T 的纯右值，可以转换成同类型 T 的亡值，此转换以该纯右值初始化为一个 T 类型的临时对象，并产生一个代表临时对象的亡值；绑定指的是引用初始化。

3. 纯右值不能具有不完整