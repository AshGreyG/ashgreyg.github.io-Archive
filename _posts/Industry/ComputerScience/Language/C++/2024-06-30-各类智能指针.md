---
title: 各类智能指针
author: AshGrey
date: 2024-06-30 00:00:00 +0800
categories: [Coumputer Science, Language]
tags: [Computer Science, C++]
---

> 本文章所属领域：
>
> [实践产业知识 - 工业产业 - 计算机科学 - 编程语言 - C++]({% post_url /Computer Science/2024-02-08-计算机科学：索引笔记 %})
>
> 本文章所需前置知识：
>
> - [C++基础知识]({% post_url /Computer Science/Language/2024-02-08-C++基础知识笔记 %})
{: .prompt-info}

<br>

## 1 unique_ptr

<br>

`unique_ptr`如同其字面意思一样，只能有一个`unique_ptr`对象指向某个 C++ 的对象，「独占」意味着不可复制，但是可以使用`std::move`转移所有权。要创建一个`unique_ptr`对象，就要使用`std::make_unique`进行创建：

<br>

``` cpp
#include <memory>
#include <iostream>
#include <string_view>

struct Song {
public:
    std::string_view _artist;
    std::string_view _title;
    Song() = default;
    Song(std::string_view a, std::string_view t)
        : _artist(a), _title(t) {
        std::cout << "Song(a, t)\n";
    }
};

std::unique_ptr<Song> song_factory(std::string_view& artist,
                                   std::string_view& title) {
    return std::make_unique<Song>(artist, title);
}



int main() {
    std::string_view str_1 = "AshGrey";
    std::string_view str_2 = "Plant";
    auto song_1 = song_factory(str_1, str_2);
//  ^^^^
//  std::unique_ptr<Song>
    std::cout << song_1->_artist << "\n"
              << song_1->_title << "\n";
    auto song_2 = std::move(song_1);
//  ^^^^
//  remove_reference_t<
//  unique_ptr<Song, default_delete<Song>> &> aka: std::unique_ptr<Song>
    if (song_1) {
        std::cout << "This is called by song_1\n"
                  << song_1->_artist << "\n"
                  << song_1->_title  << "\n";
    }
    else {
        std::cout << "This is called by song_2\n"
                  << song_2->_artist << "\n"
                  << song_2->_title  << "\n";
    }
    return 0;
}
```

<br>

|公有成员函数|说明|
|:---:|:---:|
|`release()`|若被管理对象存在，释放被管理对象的所有权，返回指向被管理对象的原始指针|
|`reset(...)`|覆写并替换管理的对象，参数接受另一个相同类型的指针|
|`swap(...)`|交换管理的对象，参数接受另一个相同类型的指针|
|`get()`|返回指向管理的对象的原始指针|

<br>

`std::unique_ptr`只有在显式地销毁或者所有权转移的时候才会不再指向原来的对象而置空，显式地调用`release()`函数返回的是普通的指针类型：

<br>

``` cpp
#include <iostream>
#include <memory>

int main() {
    auto ptr_int_1 = std::make_unique<int>(3);
    std::cout << ptr_int_1 << std::endl; // 0x13a52b0
    auto ptr_int_2 = ptr_int_1.release();
//  ^^^^
//  int *
    std::cout << ptr_int_1 << std::endl; // 0
    return 0;
}
```

<br>

注意如果使用`const`来创建`std::unique_ptr`，则无法使用`std::move`将该`std::unique_ptr`的所有权进行转移，也无法显式地调用`release()`函数（在这里所有权进行转移时会使用弃置的构造函数）：

<br>

``` cpp
#include <iostream>
#include <memory>

int main() {
    const auto ptr_int_1 = std::make_unique<int>(3);
    std::cout << ptr_int_1 << std::endl;
    auto ptr_int_2 = std::move(ptr_int_1);
//       ^^^^^^^^^
//       Call to deleted constructor of 'std::unique_ptr<int>'
/*
    in <momery>:
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;
*/
    return 0;
}
```

<br>

若 T 是某基类 B 的派生类，则`std::unique_ptr<T>`可以隐式转换为`std::unqiue_ptr<B>`，产生的`std::unique_ptr<B>`的默认删除器将使用 B 的析构函数，若 B 的析构函数非虚，则会产生未定义行为，以下是正确的代码：

<br>

``` cpp
#include <iostream>
#include <memory>

struct Based {
public:
    Based() {
        std::cout << "Based()\n";
    }
    virtual ~Based() {
        std::cout << "~Based()\n";
    }
};

struct Derived : public Based {
public:
    Derived() {
        std::cout << "Derived()\n";
    }
    ~Derived() override {
        std::cout << "~Derived()\n";
    }
};

int main() {
    Derived test_obj;
    std::cout << ".\n";
    {
        auto ptr_derived = std::make_unique<Derived>(test_obj);
        std::unique_ptr<Based> ptr_based = std::move(ptr_derived);
    }
    std::cout << ".\n";
    return 0;
}
```

<br>

正确的输出如下：

<br>

``` plaintext
Based()
Derived()
.
~Derived()
~Based()
.
~Derived()
~Based()
```

<br>

当我们的基类`Based`的析构函数非虚时，将产生错误的调用析构函数顺序，错误代码如下：

<br>

``` cpp
#include <iostream>
#include <memory>

struct Based {
public:
    Based() {
        std::cout << "Based()\n";
    }
    ~Based() {
        std::cout << "~Based()\n";
    }
};

struct Derived : public Based {
public:
    Derived() {
        std::cout << "Derived()\n";
    }
    ~Derived() {
        std::cout << "~Derived()\n";
    }
};

int main() {
    Derived test_obj;
    std::cout << ".\n";
    {
        auto ptr_derived = std::make_unique<Derived>(test_obj);
        std::unique_ptr<Based> ptr_based = std::move(ptr_derived);
    }
    std::cout << ".\n";
    return 0;
}
```

<br>

错误的输出如下：

<br>

``` plaintext
Based()
Derived()
.
~Based()
.
~Derived()
~Based()
```

<br>

## 2 shared_ptr

<br>

`std::shared_ptr`如同其字面意思一样，多个`std::shared_ptr`对象可以指向同一个 C++ 对象，其采用引用计数的方法来实现垃圾收集。可以复制`std::shared_ptr`对象，按值将其传入到函数参数中，或者分配给其他`std::shared_ptr`对象，并共享对同一个「控制块」（每当新的`std::shared_ptr`增加、超出范围或者重置时增加或者减少引用计数）的访问控制。当引用计数为零时，控制块将删除内存资源和自身。

<br>

|公有成员函数|说明|
|:---:|:---:|
|