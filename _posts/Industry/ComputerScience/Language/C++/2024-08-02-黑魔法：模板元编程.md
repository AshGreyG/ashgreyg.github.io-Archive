---
title: 黑魔法：模板元编程
author: AshGrey
date: 2024-08-02 00:00:00 +0800
categories: [Coumputer Science, Language]
tags: [Computer Science, C++]
---

> 本文章所属领域：
>
> [实践产业知识 - 工业产业 - 计算机科学 - 编程语言 - C++]({% post_url /Computer Science/2024-02-08-计算机科学：索引笔记 %})
>
> 本文章所需前置知识：
>
> - [C++基础知识]({% post_url /Computer Science/Language/2024-02-08-C++基础知识笔记 %})
{: .prompt-info}

<br>

## 1 函数模板

<br>

函数模板并不是函数，而是将函数实例化的语法：

<br>

``` cpp
#include <iostream>

template<typename T>
T myMax(T a, T b) {
    return a > b ? a : b;
}

struct Test {
  public:
    int v_;
    Test() = default;
    Test(int v) : v_(v) {}
    bool operator>(const Test& t) const {
        return this->v_ > t.v_;
    }
};

int main() {
    Test a{1};
    Test b{2};
    std::cout << myMax(a, b).v_;    // 2
    return 0;
}
```

<br>

### 1.1 万能引用和引用折叠

<br>

所谓的万能引用（转发引用），即**接受左值表达式则形参类型推导为左值引用，接受右值表达式则形参类型推导为右值引用**。通过模板或者`typedef`中的类型操作可以构成引用的引用，此时使用**引用折叠**（reference collapsing）规则：**右值引用的右值引用推导为右值引用，其余的组合均推导出左值引用**：

<br>

``` cpp
#include <iostream>
#include <type_traits>

template<typename Ty>
constexpr Ty&& myForward(Ty& arg) noexcept {
    return static_cast<Ty&&>(arg);
}

int main() {
    int test = 1;
    std::cout << std::is_same<int&&, decltype(myForward<int>(test))>::value   << "\n"   // 1
              << std::is_same<int&,  decltype(myForward<int&>(test))>::value  << "\n"   // 1
              << std::is_same<int&&, decltype(myForward<int&&>(test))>::value << "\n";  // 1
    return 0;
}
```

<br>

### 1.2 有默认实参的模板类型形参

<br>

和有默认参数的函数类似，模板类型也可以有默认的实参类型，即指定某个类型为默认类型。问题是，假设有两个不同类型的变量传入函数模板生成的函数中，且该函数可能因为传入的变量而返回不同的类型时，可以像下面这样写出返回的类型：

<br>

``` cpp
#include <iostream>

using namespace std::string_literals;

template<typename T1, typename T2, 
         typename RT = decltype(true ? T1{} : T2{})>
RT myMax(const T1& a, const T2& b) {
    return a > b ? a : b;
}

int main() {
    auto test_int = myMax(1, 1.2);
    auto test_str = myMax("1", "2"s);
    std::cout << test_int << "\n" << test_str;
    return 0;
}
```

<br>

> 这里用到了后面加上`s`的字符串，这是表示字符串在使用`auto`自动推导或者模板类型推导时，不会推导为`const char*`，而是推导为`std::string`。使用这个特性需要使用`using namespace std::string_literals`

<br>

这里最值得说道的是这里的三目运算符：
- 三目运算符构成的表达式`bool ? T1 : T2`要求`T1`和`T2`类型能够隐式转换，并且整个表达式的类型会是向上的隐式转换的「公共」类型，例如`int`和`double`的向上隐式转换类型是`double`，还有`const char*`和`std::string`的向上隐式转换类型是`std::string`；
- `decltype`检查表达式的类型或值类别；
- 这里使用`T1{}`和`T2{}`是因为必须构造临时对象以适配模板语法。

<br>

我们使用 C++ Insights 来查看这里生成的函数：可以看到生成的第一个函数的「公共」类型是`double`，生成的第二个函数的「公共」类型是`std::basic_string<char>`。

<br>

``` cpp
/* First instantiated from: insights.cpp:13 */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
double myMax<int, double, double>(const int & a, const double & b)
{
  return static_cast<double>(a) > b ? static_cast<double>(a) : b;
}
#endif


/* First instantiated from: insights.cpp:14 */
#ifdef INSIGHTS_USE_TEMPLATE
template<>
std::basic_string<char> myMax<char[2], std::basic_string<char>, std::basic_string<char> >(const char (&a)[2], const std::basic_string<char> & b)
{
  return std::operator>(a, b) ? std::basic_string<char>(a, std::allocator<char>()) : std::basic_string<char>(b);
}
#endif
```

<br>

这样使用默认实参类型的语法让整个模板多了一个类型参数，这种语法可以使用`auto`的后置返回类型来简化：

<br>

``` cpp
#include <iostream>

using namespace std::string_literals;

template<typename T1, typename T2>
auto myMax(const T1& a, const T2& b) -> decltype(true ? T1{} : T2{}) {
// or
// auto myMax(const T1& a. const T2& b) -> decltype(true ? T1{} : T2{})
    return a > b ? a : b;
}

int main() {
    auto test_int = myMax(1, 1.2);
    auto test_str = myMax("1", "2"s);
    std::cout << test_int << "\n" << test_str;
    return 0;
}
```

<br>

如果按照